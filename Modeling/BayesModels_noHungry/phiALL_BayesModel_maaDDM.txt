model{
	#Group Priors: baseline (sated)
	mu_bound ~ dnorm(2,1)
	sigma_bound ~ dnorm(0,3)I(0,)
	mu_ndt ~ dnorm(-1,1)
	sigma_ndt ~ dnorm(0,1)I(0,)
	mu_drift ~ dnorm(0,1/2)
	sigma_drift ~ dnorm(0,1/2)I(0,)
	mu_weight1 ~ dnorm(0,1/2)
	sigma_weight1 ~ dnorm(0,1/2)I(0,)
	mu_theta ~ dnorm(0,1/2)
	sigma_theta ~ dnorm(0,1/2)I(0,)
	mu_phy ~ dnorm(0,1/2)
	sigma_phy ~ dnorm(0,1/2)I(0,)	

	#Group Priors: effect of hunger
	#mu_bound_H ~ dnorm(0,1)
	#sigma_bound_H ~ dnorm(0,1)I(0,)
	#mu_ndt_H ~ dnorm(0,1)
	#sigma_ndt_H ~ dnorm(0,1)I(0,)
	#mu_drift_H ~ dnorm(0,1/2)
	#sigma_drift_H ~ dnorm(0,1/2)I(0,)
	#mu_weight1_H ~ dnorm(0,1/4)
	#sigma_weight1_H ~ dnorm(0,1/4)I(0,)	
	#mu_theta_H ~ dnorm(0,1/4)
	#sigma_theta_H ~ dnorm(0,1/4)I(0,)	
	#mu_phy_H ~ dnorm(0,1/4)
	#sigma_phy_H ~ dnorm(0,1/4)I(0,)	

	#transform SDs into precisions
	lambda_bound <- pow(sigma_bound,-2)
	lambda_ndt <- pow(sigma_ndt,-2)
	lambda_drift <- pow(sigma_drift,-2)
	lambda_weight1 <- pow(sigma_weight1,-2)
	lambda_theta <- pow(sigma_theta,-2)
	lambda_phy <- pow(sigma_phy,-2)	
	#lambda_bound_H <- pow(sigma_bound_H,-2)
	#lambda_ndt_H <- pow(sigma_ndt_H,-2)
	#lambda_drift_H <- pow(sigma_drift_H,-2)
	#lambda_weight1_H <- pow(sigma_weight1_H,-2)
	#lambda_theta_H <- pow(sigma_theta_H,-2)
	#lambda_phy_H <- pow(sigma_phy_H,-2)

	#Subject Priors
	for (s in 1:S){
		bound[s] ~ dnorm(mu_bound,lambda_bound)
		ndt[s] ~ dnorm(mu_ndt,lambda_ndt)
		drift[s] ~ dnorm(mu_drift,lambda_drift)
		weight1[s] ~ dnorm(mu_weight1,lambda_weight1)
		theta[s] ~ dnorm(mu_theta,lambda_theta)
		phy[s] ~ dnorm(mu_phy,lambda_phy)
		#bound_H[s] ~ dnorm(mu_bound_H,lambda_bound_H)
		#ndt_H[s] ~ dnorm(mu_ndt_H,lambda_ndt_H)
		#drift_H[s] ~ dnorm(mu_drift_H,lambda_drift_H)
		#weight1_H[s] ~ dnorm(mu_weight1_H,lambda_weight1_H)
		#theta_H[s] ~ dnorm(mu_theta_H,lambda_theta_H)
		#phy_H[s] ~ dnorm(mu_phy_H,lambda_phy_H)
		
		#soft-plus and phi transformations
		boundS[s] <- log(1+exp(bound[s]))
		#boundH[s] <- log(1+exp(bound[s]+bound_H[s]))
		ndtS[s] <- log(1+exp(ndt[s]))
		#ndtH[s] <- log(1+exp(ndt[s]+ndt_H[s]))
		driftS[s] <- log(1+exp(drift[s]))
		#driftH[s] <- log(1+exp(drift[s]+drift_H[s]))
		weight1S[s] <- phi(weight1[s])
		#weight1H[s] <- phi(weight1[s]+weight1_H[s])
		weight2S[s] <- 1-weight1S[s]
		#weight2H[s] <- 1-weight1H[s]
		thetaS[s] <-phi(theta[s])
		#thetaH[s] <-(theta[s]+theta_H[s])
		phyS[s] <-phi(phy[s])
		#phyH[s] <-(phy[s]+phy_H[s])				
		}
	

	#Model
	for (n in 1:N){
		VD[n] <- fixProp1[n]* (weight1S[P[n]]* (attribute1A[n]-thetaS[P[n]]*attribute1B[n])+ weight2S[P[n]]*phyS[P[n]]*(attribute2A[n]-thetaS[P[n]]*attribute2B[n]))+ fixProp2[n]*(weight1S[P[n]]*(thetaS[P[n]]*attribute1A[n]-attribute1B[n])+weight2S[P[n]]*phyS[P[n]]*(thetaS[P[n]]*attribute2A[n]-attribute2B[n]))+ fixProp3[n]*(weight1S[P[n]]*phyS[P[n]]*(attribute1A[n]-thetaS[P[n]]*attribute1B[n])+weight2S[P[n]]*(attribute2A[n]-thetaS[P[n]]*attribute2B[n]))+ fixProp4[n]*(weight1S[P[n]]*phyS[P[n]]*(thetaS[P[n]]*attribute1A[n]-attribute1B[n])+weight2S[P[n]]*(thetaS[P[n]]*attribute2A[n]-attribute2B[n]))

		RT[n] ~ dwiener(boundS[P[n]],ndtS[P[n]],0.5,driftS[P[n]]*VD[n])
		}
}
