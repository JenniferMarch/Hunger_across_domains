---
title: "maaDDMsp"
author: "Jennifer March (jennifer.march@uni-hamburg.de)"
date: "3/26/2024"
output: html_document
---

# General Info

This script contains all the models tested in our manuscript (https://osf.io/preprints/psyarxiv/wvfnb). It requires JAGS. The script is structured s follows:

1. **Preparation:** loading libraries and load workspace
2. **Multi-attribute attentional DDM with starting point bias:** Function, Estimate maaDDMsp, Test Parameters and some graphs (corresponds to maaDDMsp)
3. **Posterior Predictive Checks** for maaDDMsp with graph to check fit to data


# 1 Preparations
## 1.1 Load Libraries
```{r}
#clear working environment
rm(list=ls())

#clear all plots
#if(!is.null(dev.list())) dev.off()

#load required libraries
library(rtdists)
library(dfoptim)
library(readxl)
library(tidyr)
library(dplyr)
library(zoo)
library(tibble)
library(readr)
pacman::p_load(tidyverse, ez)
#parallel computing stuff
library(parallel)
library(doParallel)
library(foreach)
numCores <- detectCores()
registerDoParallel(cores=numCores)
#JAGS packages
library(R2jags) #should be put at the start but keep it here for the moment...
library(rtdists) #to be on the safe side when loading workspace (and not executing the first chunk above)
```

## 1.2 Create Theme for Plots
```{r}
library(ggplot2)
myTheme <- theme(
  axis.line = element_line(colour = "black"), 
  panel.grid.major = element_blank(), 
  panel.grid.minor = element_blank(),  
  panel.border = element_blank(),   
  panel.background = element_blank(),
  text=element_text(size=16, colour = "black"), 
  axis.title.x = element_text(size=20, face="bold", colour = "black"), 
  axis.title.y = element_text( size=20, face="bold", colour = "black"),
  axis.text = element_text(size=16),
  strip.text =  element_text( size=16),
  strip.background = element_rect(fill = "white", colour = "black"),
  legend.background = element_rect(colour = "black"),
  legend.key = element_blank(),
  legend.key.size = unit(3, "lines"))
```

## 1.3 Load workspace (if required)
```{r}
# Load data
load("data_social_prep.RData")
```

# 2 Multiattribute attentional DDM + SP
## 2.1 Estimate maaDDM_sp with hierarchical Bayesian modeling (JAGS)
```{r}
# get data and initial values together and specify the model
ddmData <- list('N'=N,'S'=S,'P'=P,'H'=H,'attribute1A'=selfA,'attribute1B'=selfB,'attribute2A'=ngoA,'attribute2B'=ngoB,'RT'=RT,
                'fixProp1'=fixProp1,'fixProp2'=fixProp2,'fixProp3'=fixProp3,'fixProp4'=fixProp4)

#starting values
nChains <- 8

#parallel computing apparently not possible
T1<-Sys.time()
maaDDMsp <- jags.parallel(ddmData,inits = NULL,#jags.seed = sample(100:999,1),
                    parameters.to.save = c('mu_bound','sigma_bound','mu_ndt','sigma_ndt',
                                           'mu_drift','sigma_drift','mu_weight1','sigma_weight1',
                                           'mu_theta','sigma_theta','mu_phy','sigma_phy','mu_sp','sigma_sp',
                                           'mu_bound_H','sigma_bound_H','mu_ndt_H','sigma_ndt_H',
                                           'mu_drift_H','sigma_drift_H','mu_weight1_H','sigma_weight1_H',
                                           'mu_theta_H','sigma_theta_H','mu_phy_H','sigma_phy_H','mu_sp_H','sigma_sp_H',
                                           'bound','ndt','drift','weight1','theta','phy','sp',
                                           'bound_H','ndt_H','drift_H','weight1_H','theta_H','phy_H','sp_H'),
                    model.file = "BayesModel_maaDDM_sp.txt",working.directory = 'BayesModels', # make sure to rename working directory/provide path if not working with Rproject 
                    n.chains = nChains, n.iter = 60000, n.burnin = 30000,n.thin = 12, DIC = TRUE,jags.module = c("glm","dic","wiener"))
T2<-Sys.time() #T2-T1

# check convergence
ddmRhats <- maaDDMsp$BUGSoutput$summary[,8] #check with max(Rhats), which should ideally be < 1.01 (1.05 would also be okay)
max(ddmRhats)
maaDDMsp$BUGSoutput$DIC
#DIC 29951.05 Rhat: 1.027
save.image(file='maaddm_sp_social.RData')
```

## 2.2.maaDDM_sp: check parameters (group posteriors)
```{r}
#get group parameter estimates in transformed form 
boundSep_S <- log(1+exp(maaDDMsp$BUGSoutput$sims.list$mu_bound))
boundSep_H <- log(1+exp(maaDDMsp$BUGSoutput$sims.list$mu_bound+maaDDMsp$BUGSoutput$sims.list$mu_bound_H))
boundSep_delta <- maaDDMsp$BUGSoutput$sims.list$mu_bound_H

ndt_S <- log(1+exp(maaDDMsp$BUGSoutput$sims.list$mu_ndt))
ndt_H <- log(1+exp(maaDDMsp$BUGSoutput$sims.list$mu_ndt+maaDDMsp$BUGSoutput$sims.list$mu_ndt_H))
ndt_delta <- maaDDMsp$BUGSoutput$sims.list$mu_ndt_H

weight1_S <- pnorm(maaDDMsp$BUGSoutput$sims.list$mu_weight1)
weight1_H <- pnorm(maaDDMsp$BUGSoutput$sims.list$mu_weight1+maaDDMsp$BUGSoutput$sims.list$mu_weight1_H)
weight1_delta <- maaDDMsp$BUGSoutput$sims.list$mu_weight1_H

drift_S <- log(1+exp(maaDDMsp$BUGSoutput$sims.list$mu_drift))
drift_H <- log(1+exp(maaDDMsp$BUGSoutput$sims.list$mu_drift+maaDDMsp$BUGSoutput$sims.list$mu_drift_H))
drift_delta <- maaDDMsp$BUGSoutput$sims.list$mu_drift_H

sp_S <- pnorm(maaDDMsp$BUGSoutput$sims.list$mu_sp)
sp_H <- pnorm(maaDDMsp$BUGSoutput$sims.list$mu_sp+maaDDMsp$BUGSoutput$sims.list$mu_sp_H)
sp_delta <- maaDDMsp$BUGSoutput$sims.list$mu_sp_H

theta_S <- (maaDDMsp$BUGSoutput$sims.list$mu_theta)
theta_H <- (maaDDMsp$BUGSoutput$sims.list$mu_theta+maaDDMsp$BUGSoutput$sims.list$mu_theta_H)
theta_delta <- maaDDMsp$BUGSoutput$sims.list$mu_theta_H

phy_S <- (maaDDMsp$BUGSoutput$sims.list$mu_phy)
phy_H <- (maaDDMsp$BUGSoutput$sims.list$mu_phy+maaDDMsp$BUGSoutput$sims.list$mu_phy_H)
phy_delta <- maaDDMsp$BUGSoutput$sims.list$mu_phy_H

# PLOT 

#1) self weight 
histGran <- (-300:300)/150
# Create a data frame
datatw <- data.frame(weight1_S = weight1_S, weight1_H = weight1_H)
# Plot using ggplot2
selfweight1<-ggplot(datatw, aes(x = weight1_S)) +
  geom_histogram(binwidth = 1/90, fill = "cornflowerblue", alpha = 0.5, color = "black") +
  geom_histogram(aes(x = weight1_H), binwidth = 1/90, fill = "gold", alpha = 0.5, color = "black") +
  labs(x = "Self Weight", y = "Frequency") +
  #scale_x_continuous(limits = c(-0.1, 0.25)) +
  ylim(0, 5000)+
  myTheme
# effect of hunger 
data_deltatw <- data.frame(weight1_delta = weight1_delta)
HDI_tw <- quantile(weight1_delta,c(.025,.975))
# Plot using ggplot2
selfweight2<-ggplot(data_deltatw, aes(x = weight1_delta)) +
  geom_histogram(binwidth = 1/20, fill = "grey", alpha = 0.5, color = "black") +
  geom_vline(xintercept = 0, color = "red", size = 1.5) +
  geom_vline(xintercept = HDI_tw, color = "black", size = 1, linetype = "dashed") +
  ylim(0, 5000)+
  labs(x = "Effect of Hunger", y = "Frequency") +
  myTheme

# 2) Scaling
histGran <- (-300:300)/150
# Create a data frame
datascale <- data.frame(drift_S = drift_S, drift_H = drift_H)
# Plot using ggplot2
drift1<-ggplot(datascale, aes(x = drift_S)) +
  geom_histogram(binwidth = 1/140, fill = "cornflowerblue", alpha = 0.5, color = "black") +
  geom_histogram(aes(x = drift_H), binwidth = 1/140, fill = "gold", alpha = 0.5, color = "black") +
  labs(x = "Drift Scaling", y = "Frequency") +
  ylim(0, 5000)+
  #scale_x_continuous(limits = c(-0.1, 0.25)) +
  myTheme

# effect of hunger 
data_deltascale <- data.frame(drift_delta = drift_delta)
HDI_drift <- quantile(drift_delta,c(.025,.975))
# Plot using ggplot2
drift2<-ggplot(data_deltascale, aes(x = drift_delta)) +
  geom_histogram(binwidth = 1/50, fill = "grey", alpha = 0.5, color = "black") +
  geom_vline(xintercept = 0, color = "red", size = 1.5) +
  geom_vline(xintercept = HDI_drift, color = "black", size = 1, linetype = "dashed") +
  ylim(0, 5000)+
  labs(x = "Effect of Hunger", y = "Frequency") +
  myTheme

# 3) Starting Point
histGran <- (-300:300)/150
# Create a data frame
datasp <- data.frame(sp_S = sp_S, sp_H = sp_H)
# Plot using ggplot2
startpoint1<-ggplot(datasp, aes(x = sp_S)) +
  geom_histogram(binwidth = 1/200, fill = "cornflowerblue", alpha = 0.5, color = "black") +
  geom_histogram(aes(x = sp_H), binwidth = 1/200, fill = "gold", alpha = 0.5, color = "black") +
  labs(x = "Starting point Bias", y = "Frequency") +
  ylim(0, 5000)+
  #scale_x_continuous(limits = c(-0.1, 0.25)) +
  myTheme

HDI_sps <- quantile(sp_S,c(.025,.975))
HDI_sph <- quantile(sp_H,c(.025,.975))

# effect of hunger 
data_deltasp <- data.frame(sp_delta = sp_delta)
HDI_sp <- quantile(sp_delta,c(.025,.975))
# Plot using ggplot2
startpoint2<-ggplot(data_deltasp, aes(x = sp_delta)) +
  geom_histogram(binwidth = 1/100, fill = "grey", alpha = 0.5, color = "black") +
  geom_vline(xintercept = 0, color = "red", size = 1.5) +
  geom_vline(xintercept = HDI_sp, color = "black", size = 1, linetype = "dashed") +
  ylim(0, 5000)+
  labs(x = "Effect of Hunger", y = "Frequency") +
  myTheme

#4) Boundary seperation
histGran <- (-300:300)/150
# Create a data frame
databound <- data.frame(boundSep_S = boundSep_S, boundSep_H = boundSep_H)
# Plot using ggplot2
bound1<-ggplot(databound, aes(x = boundSep_S)) +
  geom_histogram(binwidth = 1/30, fill = "cornflowerblue", alpha = 0.5, color = "black") +
  geom_histogram(aes(x = boundSep_H), binwidth = 1/30, fill = "gold", alpha = 0.5, color = "black") +
  labs(x = "Boundary Seperation", y = "Frequency") +
  #scale_x_continuous(limits = c(-0.1, 0.25)) +
  ylim(0, 5000)+
  myTheme
# effect of hunger 
data_deltabound <- data.frame(boundSep_delta = boundSep_delta)
HDI_bound <- quantile(boundSep_delta,c(.025,.975))
# Plot using ggplot2
bound2<-ggplot(data_deltabound, aes(x = boundSep_delta)) +
  geom_histogram(binwidth = 1/40, fill = "grey", alpha = 0.5, color = "black") +
  geom_vline(xintercept = 0, color = "red", size = 1.5) +
  geom_vline(xintercept = HDI_bound, color = "black", size = 1, linetype = "dashed") +
  ylim(0, 5000)+
  labs(x = "Effect of Hunger", y = "Frequency") +
  myTheme


# 5) nDT
histGran <- (-300:300)/150
# Create a data frame
datanDT <- data.frame(ndt_S = ndt_S, ndt_H = ndt_H)
# Plot using ggplot2
nDT1<-ggplot(datanDT, aes(x = ndt_S)) +
  geom_histogram(binwidth = 1/140, fill = "cornflowerblue", alpha = 0.5, color = "black") +
  geom_histogram(aes(x = ndt_H), binwidth = 1/140, fill = "gold", alpha = 0.5, color = "black") +
  labs(x = "Non-Decision Time", y = "Frequency") +
  ylim(0, 5000)+
  #scale_x_continuous(limits = c(-0.1, 0.25)) +
  myTheme

# effect of hunger 
data_deltandt <- data.frame(ndt_delta = ndt_delta)
HDI_ndt <- quantile(ndt_delta,c(.025,.975))
# Plot using ggplot2
nDT2<-ggplot(data_deltandt, aes(x = ndt_delta)) +
  geom_histogram(binwidth = 1/100, fill = "grey", alpha = 0.5, color = "black") +
  geom_vline(xintercept = 0, color = "red", size = 1.5) +
  geom_vline(xintercept = HDI_ndt, color = "black", size = 1, linetype = "dashed") +
  ylim(0, 5000)+
  labs(x = "Effect of Hunger", y = "Frequency") +
  myTheme

nDT1
nDT2

# 6) Theta
histGran <- (-300:300)/150
# Create a data frame
datatheta <- data.frame(theta_S = theta_S, theta_H = theta_H)
# Plot using ggplot2
theta1<-ggplot(datatheta, aes(x = theta_S)) +
  geom_histogram(binwidth = 1/220, fill = "cornflowerblue", alpha = 0.5, color = "black") +
  geom_histogram(aes(x = theta_H), binwidth = 1/220, fill = "gold", alpha = 0.5, color = "black") +
  labs(x = "Theta", y = "Frequency") +
  ylim(0, 5000)+
  #scale_x_continuous(limits = c(-0.1, 0.25)) +
  myTheme

# effect of hunger 
data_deltatheta <- data.frame(theta_delta = theta_delta)
HDI_theta <- quantile(theta_delta,c(.025,.975))
# Plot using ggplot2
theta2<-ggplot(data_deltatheta, aes(x = theta_delta)) +
  geom_histogram(binwidth = 1/220, fill = "grey", alpha = 0.5, color = "black") +
  geom_vline(xintercept = 0, color = "red", size = 1.5) +
  geom_vline(xintercept = HDI_theta, color = "black", size = 1, linetype = "dashed") +
  ylim(0, 5000)+
  labs(x = "Effect of Hunger", y = "Frequency") +
  myTheme

theta1
theta2


# 7) Phi
histGran <- (-300:300)/150
# Create a data frame
dataphy <- data.frame(phy_S = phy_S, phy_H = phy_H)
# Plot using ggplot2
phy1<-ggplot(dataphy, aes(x = phy_S)) +
  geom_histogram(binwidth = 1/40, fill = "cornflowerblue", alpha = 0.5, color = "black") +
  geom_histogram(aes(x = phy_H), binwidth = 1/40, fill = "gold", alpha = 0.5, color = "black") +
  labs(x = "Phi", y = "Frequency") +
  ylim(0, 5000)+
  #scale_x_continuous(limits = c(-0.1, 0.25)) +
  myTheme

# effect of hunger 
data_deltaphy <- data.frame(phy_delta = phy_delta)
HDI_phy <- quantile(phy_delta,c(.025,.975))
# Plot using ggplot2
phy2<-ggplot(data_deltaphy, aes(x = phy_delta)) +
  geom_histogram(binwidth = 1/40, fill = "grey", alpha = 0.5, color = "black") +
  geom_vline(xintercept = 0, color = "red", size = 1.5) +
  geom_vline(xintercept = HDI_phy, color = "black", size = 1, linetype = "dashed") +
  ylim(0, 5000)+
  labs(x = "Effect of Hunger", y = "Frequency") +
  myTheme

phy1
phy2

library("cowplot")
# Arrange the plots side by side
combined_plot_maaddm2 <- plot_grid(selfweight1, selfweight2, drift1, drift2, nDT1, nDT2, bound1, bound2, theta1, theta2, phy1, phy2, startpoint1, startpoint2, labels = c("a", "", "b", "", "c", "", "d", "", "e", "", "f", "", "g", ""), label_size = 20, ncol = 4, align = "h", column_spacing = unit(c(1, 3, 1, 1, 3, 1, 1, 3, 1,1), "cm"))
combined_plot_maaddm2
# Save the combined plot as a PNG file
ggsave("maaddmsp_social.png", combined_plot_maaddm2, width = 16, height = 12)
```


# 3 Posterior predictive checks = simulate maaDDM_sp
## 3.1 PPC Function
```{r}
#function for simulation (rtdists package is used to simulated the DDM)
# sim_maaDDMsp  <- function(parameters,selfA,selfB,ngoA,ngoB,fixProps){
# 
#   #extract free parameters; note that order of parameters follows rtdists, not dwiener
#   boundarySeparation <- parameters[1]
#   ndt <- parameters[2]
#   drift <- parameters[3]
#   weight1 <- parameters[4]
#   theta <- parameters[5]
#   phi <- parameters[6] #okay to call it "phi" in R
#   startingPoint <- parameters[7]*boundarySeparation #don't forget: sp is NOT relative in rtdists (but it is in dwiener; gosh!)
# 
#   #compute trial-wise value difference
#   valueDifference <- fixProps[,1]*(weight1*(selfA-theta*selfB)+(1-weight1)*phi*(ngoA-theta*ngoB))+
#                      fixProps[,2]*(weight1*(theta*selfA-selfB)+(1-weight1)*phi*(theta*ngoA-ngoB))+
#                      fixProps[,3]*(weight1*phi*(selfA-theta*selfB)+(1-weight1)*(ngoA-theta*ngoB))+
#                      fixProps[,4]*(weight1*phi*(theta*selfA-selfB)+(1-weight1)*(theta*ngoA-ngoB))
# 
#   #Simulate the DDM and store choices and RTs
#   nTrials <- length(valueDifference)
#   choices <- rep(NA, nTrials)
#   rts <- rep(NA, nTrials)
#   for (i in 1:nTrials) {
#     result <- rdiffusion(1,boundarySeparation,drift*valueDifference[i],ndt,startingPoint)
# 
#     choices[i] <- ifelse(result$response == "upper", 2, 1)
#     rts[i] <- result$rt
#   }
#   simdata<-cbind(choices, rts)
# 
#     # Return the choices and RTs
#   return(simdata)
# }

# Recommended: Save simdata
```

## 3.2 Simulate
```{r}
# #generate posterior predictives (loop over samples taken, subjects, conditions)
# nPostPred <- 200
# ppSample <- sample(maaDDMsp$BUGSoutput$n.sims,nPostPred) #draw samples from posterior (without replacement)
# ppDat_JAGS_hungry_choices <- matrix(NA,nrow = sum(H==1),ncol = nPostPred)
# ppDat_JAGS_sated_choices <- matrix(NA,nrow = sum(H==0),ncol = nPostPred)
# ppDat_JAGS_hungry_rts <- matrix(NA,nrow = sum(H==1),ncol = nPostPred)
# ppDat_JAGS_sated_rts <- matrix(NA,nrow = sum(H==0),ncol = nPostPred)
# #conflictTrials_hungry = c()
# #conflictTrials_sated = c()
# for (p in 1:nPostPred){
#   x = ppSample[p] #current sample
#   simDat_JAGS_hungry<-data.frame(choices = numeric(), rts = numeric())
#   simDat_JAGS_sated<-data.frame(choices = numeric(), rts = numeric())
#   for  (s in (unique(data_sated$subject))){
#     sInJAGS <- which(uID==s)
#     for (t in 1:2){
#       if (t == 1){ #session-specific stuff up front; note that order of parameters follows rtdists, not dwiener
#         sub <- data_hungry[data_hungry$subject == s, ] #hungry
#         fixatedElement <- expanded_table_h[[which(unique(data_hungry$subject)==s)]]
#         parameters <- c(log(1+exp(maaDDMsp$BUGSoutput$sims.list$bound[x,sInJAGS]+maaDDMsp$BUGSoutput$sims.list$bound_H[x,sInJAGS])),
#                       log(1+exp(maaDDMsp$BUGSoutput$sims.list$ndt[x,sInJAGS]+maaDDMsp$BUGSoutput$sims.list$ndt_H[x,sInJAGS])),
#                       log(1+exp(maaDDMsp$BUGSoutput$sims.list$drift[x,sInJAGS]+maaDDMsp$BUGSoutput$sims.list$drift_H[x,sInJAGS])),
#                       pnorm(maaDDMsp$BUGSoutput$sims.list$weight1[x,sInJAGS]+maaDDMsp$BUGSoutput$sims.list$weight1_H[x,sInJAGS]),
#                       (maaDDMsp$BUGSoutput$sims.list$theta[x,sInJAGS]+maaDDMsp$BUGSoutput$sims.list$theta_H[x,sInJAGS]),
#                       (maaDDMsp$BUGSoutput$sims.list$phy[x,sInJAGS]+maaDDMsp$BUGSoutput$sims.list$phy_H[x,sInJAGS]),
#                       pnorm(maaDDMsp$BUGSoutput$sims.list$sp[x,sInJAGS]+maaDDMsp$BUGSoutput$sims.list$sp_H[x,sInJAGS]))
#       } else {
#         sub <- data_sated[data_sated$subject == s, ] #sated
#         fixatedElement <- expanded_table_s[[which(unique(data_sated$subject)==s)]]
#         parameters <- c(log(1+exp(maaDDMsp$BUGSoutput$sims.list$bound[x,sInJAGS])),
#                       log(1+exp(maaDDMsp$BUGSoutput$sims.list$ndt[x,sInJAGS])),
#                       log(1+exp(maaDDMsp$BUGSoutput$sims.list$drift[x,sInJAGS])),
#                       pnorm(maaDDMsp$BUGSoutput$sims.list$weight1[x,sInJAGS]),
#                       (maaDDMsp$BUGSoutput$sims.list$theta[x,sInJAGS]),
#                       (maaDDMsp$BUGSoutput$sims.list$phy[x,sInJAGS]),
#                       pnorm(maaDDMsp$BUGSoutput$sims.list$sp[x,sInJAGS]))
#       }
# 
#       #arrange input data
#       selfAi <- sub$self_left
#       selfBi <- sub$self_right
#       ngoAi <- sub$ngo_left
#       ngoBi <- sub$ngo_right
#       ntrialsi <- nrow(sub)
#       fixProps <- matrix(nrow = ntrialsi,ncol = 4)
#       for (n in 1:ntrialsi){
#         fEn <- fixatedElement[1:round(sub$RT[n]),n] #stream of fixated elements in current trials
#         fixProps[n,] <- c(sum(na.omit(fEn==1)),sum(na.omit(fEn==2)),sum(na.omit(fEn==3)),sum(na.omit(fEn==4)))/sum(na.omit(fEn>=1))
#       }
#       #recode everything into self vs. ngo choice
#       selfL <- (selfAi>selfBi) #whether selfish option was left
#       selfAi <- sub$self_left*(selfL==T)+sub$self_right*(selfL==F)
#       selfBi <- sub$self_left*(selfL==F)+sub$self_right*(selfL==T)
#       ngoAi <- sub$ngo_left*(selfL==T)+sub$ngo_right*(selfL==F)
#       ngoBi <- sub$ngo_left*(selfL==F)+sub$ngo_right*(selfL==T)
#       fixProps <- matrix(c(fixProps[,1]*(selfL==T)+fixProps[,2]*(selfL==F),fixProps[,1]*(selfL==F)+fixProps[,2]*(selfL==T),
#                      fixProps[,3]*(selfL==T)+fixProps[,4]*(selfL==F),fixProps[,3]*(selfL==F)+fixProps[,4]*(selfL==T)),ncol=4)
#       #rescale self and ngo values to lie between 0 and 10 (as in Yang & Krajbich)
#       selfAi <- selfAi
#       selfBi <- selfBi
#       ngoAi <- ngoAi
#       ngoBi <- ngoBi
#       #take only trials with fixations
#       validTrials <- which((is.na(fixProps[,1])==0)|(is.na(fixProps[,2])==0)|(is.na(fixProps[,3])==0)|(is.na(fixProps[,4])==0))
#       selfAi <- selfAi[validTrials]
#       selfBi <- selfBi[validTrials]
#       ngoAi <- ngoAi[validTrials]
#       ngoBi <- ngoBi[validTrials]
#       fixProps <- fixProps[validTrials,]
# 
#       #simulate
#       simDat <- sim_maaDDMsp(parameters,selfAi,selfBi,ngoAi,ngoBi,fixProps)
#       if (t==1){
#         simDat_JAGS_hungry <- rbind(simDat_JAGS_hungry, simDat)
#         # if (p==nPostPred){ #save trial info at the last iteration
#         #   conflictTrials <- ((selfAi>selfBi)&(ngoAi<ngoBi))|((selfAi<selfBi)&(ngoAi>ngoBi))
#         #   conflictTrials_hungry <- c(conflictTrials_hungry,conflictTrials)
#         # }
#       } else {
#         simDat_JAGS_sated <- rbind(simDat_JAGS_sated, simDat)
#         # if (p==nPostPred){ #save trial info at the last iteration
#         #   conflictTrials <- ((selfAi>selfBi)&(ngoAi<ngoBi))|((selfAi<selfBi)&(ngoAi>ngoBi))
#         #   conflictTrials_sated <- c(conflictTrials_sated,conflictTrials)
#         # }
#       }
#     }
#   }
#   ppDat_JAGS_hungry_choices[,p] = simDat_JAGS_hungry$choices
#   ppDat_JAGS_hungry_rts[,p] = simDat_JAGS_hungry$rts
#   ppDat_JAGS_sated_choices[,p] = simDat_JAGS_sated$choices
#   ppDat_JAGS_sated_rts[,p] = simDat_JAGS_sated$rts
# 
#   flush.console()
#   msg = sprintf('Done with posterior predictive sample: %d',p)
#   print(msg)
# }

```

## 3.3 Preprocess simulated data 
only execute once!
```{r}
# 
# # include only conflict trials (one tastier vs. one ngoier option)
# #ppDat_JAGS_hungry_choices <- ppDat_JAGS_hungry_choices[conflictTrials_hungry,]
# #ppDat_JAGS_hungry_rts <- ppDat_JAGS_hungry_rts[conflictTrials_hungry,]
# #ppDat_JAGS_sated_choices <- ppDat_JAGS_sated_choices[conflictTrials_sated,]
# #ppDat_JAGS_sated_rts <- ppDat_JAGS_sated_rts[conflictTrials_sated,]
# 
# # exclude too fast and slow responses (as done for the data)
# ppDat_JAGS_hungry_choices[ppDat_JAGS_hungry_rts>10] = NA
# ppDat_JAGS_hungry_choices[ppDat_JAGS_hungry_rts<.25] = NA
# ppDat_JAGS_hungry_rts[ppDat_JAGS_hungry_rts>10] = NA
# ppDat_JAGS_hungry_rts[ppDat_JAGS_hungry_rts<.25] = NA
# ppDat_JAGS_sated_choices[ppDat_JAGS_sated_rts>10] = NA
# ppDat_JAGS_sated_choices[ppDat_JAGS_sated_rts<.25] = NA
# ppDat_JAGS_sated_rts[ppDat_JAGS_sated_rts>10] = NA
# ppDat_JAGS_sated_rts[ppDat_JAGS_sated_rts<.25] = NA
# 
# #data: quantiles
# DDMquants <- seq(.1,.9,.2)
# quants_self_sated <- matrix(NA,nrow = nPostPred,ncol = 5)
# quants_ngo_sated <- matrix(NA,nrow = nPostPred,ncol = 5)
# quants_self_hungry <- matrix(NA,nrow = nPostPred,ncol = 5)
# quants_ngo_hungry <- matrix(NA,nrow = nPostPred,ncol = 5)
# for (p in 1:nPostPred){
#   quants_self_sated[p,] <- quantile(ppDat_JAGS_sated_rts[ppDat_JAGS_sated_choices[,p]==2,p],DDMquants,na.rm = T)
#   quants_ngo_sated[p,] <- quantile(ppDat_JAGS_sated_rts[ppDat_JAGS_sated_choices[,p]==1,p],DDMquants,na.rm = T)
#   quants_self_hungry[p,] <- quantile(ppDat_JAGS_hungry_rts[ppDat_JAGS_hungry_choices[,p]==2,p],DDMquants,na.rm = T)
#   quants_ngo_hungry[p,] <- quantile(ppDat_JAGS_hungry_rts[ppDat_JAGS_hungry_choices[,p]==1,p],DDMquants,na.rm = T)
# }
# #data: overall choice probability
# prob_self_sated <- colMeans(ppDat_JAGS_sated_choices==2,na.rm = T)
# prob_ngo_sated <- colMeans(ppDat_JAGS_sated_choices==1,na.rm = T)
# prob_self_hungry <- colMeans(ppDat_JAGS_hungry_choices==2,na.rm = T)
# prob_ngo_hungry <- colMeans(ppDat_JAGS_hungry_choices==1,na.rm = T)
# 
# #get 95% HDIs (highest density interval)
# HDI_prob_self_sated <- quantile(prob_self_sated,c(.025,.975))
# HDI_prob_ngo_sated <- quantile(prob_ngo_sated,c(.025,.975))
# HDI_prob_self_hungry <- quantile(prob_self_hungry,c(.025,.975))
# HDI_prob_ngo_hungry <- quantile(prob_ngo_hungry,c(.025,.975))
# HDI_quants_self_sated <- matrix(nrow = length(DDMquants),ncol = 2)
# HDI_quants_ngo_sated <- matrix(nrow = length(DDMquants),ncol = 2)
# HDI_quants_self_hungry <- matrix(nrow = length(DDMquants),ncol = 2)
# HDI_quants_ngo_hungry <- matrix(nrow = length(DDMquants),ncol = 2)
# for (q in 1:length(DDMquants)){
#   HDI_quants_self_sated[q,] <- quantile(quants_self_sated[,q],c(.025,.975))
#   HDI_quants_ngo_sated[q,] <- quantile(quants_ngo_sated[,q],c(.025,.975))
#   HDI_quants_self_hungry[q,] <- quantile(quants_self_hungry[,q],c(.025,.975))
#   HDI_quants_ngo_hungry[q,] <- quantile(quants_ngo_hungry[,q],c(.025,.975))
# }


```

## 3.4 PLot it 
Generates Quantile Plot as shown in Supplements
```{r}
# png(filename = "posterior_predictives_maaDDM2.png", width = 800, height = 600)
# par(fig = c(0, 0.8, 0, 1), mar = c(5, 6, 4, 4), oma = c(0, 0, 0, 0), xaxs = "i", yaxs = "i")
# 
# #draw (thin) lines for the "midpoints" of the HDIs
# plot(rowMeans(HDI_quants_ngo_sated), mean(HDI_prob_ngo_sated) * DDMquants, type = 'l', col = "cornflowerblue",
#      ylim = c(0, 1), xlim = c(0, 5),
#      xlab =  substitute(paste(bold('RT (sec)'))), ylab = substitute(paste(bold('Cumulative Probability'))), lwd = 5, pch = 2, bty = 'L',
#      main = '', cex.axis = 2, cex.lab = 2, cex.main = 2.5, axes = FALSE)
# lines(rowMeans(HDI_quants_self_sated), mean(HDI_prob_self_sated) * DDMquants, type = 'l', col = "cornflowerblue", lwd = 5, pch = 2, lty = 2)
# lines(rowMeans(HDI_quants_ngo_hungry), mean(HDI_prob_ngo_hungry) * DDMquants, type = 'l', col = "gold", lwd = 5, pch = 2)
# lines(rowMeans(HDI_quants_self_hungry), mean(HDI_prob_self_hungry) * DDMquants, type = 'l', col = "gold", lwd = 5, pch = 2, lty = 2)
# 
# 
# 
# #draw HDIs as errorbars (horizontal for RT, vertical for choice probability)
# for (q in 1:length(DDMquants)){
#   lines(HDI_quants_ngo_sated[q,],rep(mean(HDI_prob_ngo_sated) * DDMquants[q],2),type = 'l', col = "cornflowerblue",lwd=5)
#   lines(rep(mean(HDI_quants_ngo_sated[q,]),2),HDI_prob_ngo_sated * DDMquants[q],type = 'l', col = "cornflowerblue",lwd=5)
#   lines(HDI_quants_self_sated[q,],rep(mean(HDI_prob_self_sated) * DDMquants[q],2),type = 'l', col = "cornflowerblue",lwd=5)
#   lines(rep(mean(HDI_quants_self_sated[q,]),2),HDI_prob_self_sated * DDMquants[q],type = 'l', col = "cornflowerblue",lwd=5)
#   lines(HDI_quants_ngo_hungry[q,],rep(mean(HDI_prob_ngo_hungry) * DDMquants[q],2),type = 'l', col = "gold",lwd=5)
#   lines(rep(mean(HDI_quants_ngo_hungry[q,]),2),HDI_prob_ngo_hungry * DDMquants[q],type = 'l', col = "gold",lwd=5)
#   lines(HDI_quants_self_hungry[q,],rep(mean(HDI_prob_self_hungry) * DDMquants[q],2),type = 'l', col = "gold",lwd=5)
#   lines(rep(mean(HDI_quants_self_hungry[q,]),2),HDI_prob_self_hungry * DDMquants[q],type = 'l', col = "gold",lwd=5)
# }
# 
# #draw the datapoints as black lines
# RT_H = RT[H==1]
# data_choice_self_hungry = mean(RT_H>0)
# data_choice_ngo_hungry = mean(RT_H<0)
# RT_S = RT[H==0]
# data_choice_self_sated = mean(RT_S>0)
# data_choice_ngo_sated = mean(RT_S<0)
# data_quants_self_hungry =  quantile(RT_H[(RT_H>0)],DDMquants)
# data_quants_ngo_hungry =  quantile(-RT_H[(RT_H<0)],DDMquants)
# data_quants_self_sated =  quantile(RT_S[(RT_S>0)],DDMquants)
# data_quants_ngo_sated =  quantile(-RT_S[(RT_S<0)],DDMquants)
# lines(data_quants_ngo_sated, data_choice_ngo_sated * DDMquants, type = 'b', col = "black", lwd = 2, pch = 1, lty = 1)
# lines(data_quants_self_sated, data_choice_self_sated * DDMquants, type = 'b', col = "black", lwd = 2, pch = 1, lty = 2)
# lines(data_quants_ngo_hungry, data_choice_ngo_hungry * DDMquants, type = 'b', col = "black", lwd = 1, pch = 1, lty = 1)
# lines(data_quants_self_hungry, data_choice_self_hungry * DDMquants, type = 'b', col = "black", lwd = 2, pch = 1, lty = 2)
# 
# legend("topleft", legend = c('selfish hungry', 'selfish sated', 'prosocial sated', 'prosocial hungry','selfish data','prosocial data'),
#        col = c("gold", "cornflowerblue", "cornflowerblue", "gold","black","black"),
#        lty = c(2, 2, 1, 1,2,1), lwd = c(4, 4, 4, 4,4,4), bty = 'n', cex = 2)
# 
# 
# # Add y-axis with upright labels
# axis(1, lwd=3, cex.axis=1.5)
# axis(2, lwd=3, cex.axis=1.5, las=1)
# 
# dev.off()
```



