---
title: "maaDDM2phisp"
author: "Jennifer March (jennifer.march@uni-hamburg.de)"
date: "3/26/2024"
output: html_document
---

# General Info

This script contains all the models tested in our manuscript (https://osf.io/preprints/psyarxiv/wvfnb). It requires JAGS. The script is structured s follows:

1. **Preparation:** loading libraries and load workspace
2. **Multi-attribute attentional DDM with 2Phi with sp:** Function, Estimate maaDDM2phisp, Test Parameters and some graphs (corresponds to maaDDM2phisp)
3. **Posterior Predictive Checks** for maaDDM2phisp with graph to check fit to data


# 1 Preparations
## 1.1 Load Libraries
```{r}
#clear working environment
rm(list=ls())

#clear all plots
#if(!is.null(dev.list())) dev.off()

#load required libraries
library(rtdists)
library(dfoptim)
library(readxl)
library(tidyr)
library(dplyr)
library(zoo)
library(tibble)
library(readr)
pacman::p_load(tidyverse, ez)
#parallel computing stuff
library(parallel)
library(doParallel)
library(foreach)
numCores <- detectCores()
registerDoParallel(cores=numCores)
#JAGS packages
library(R2jags) #should be put at the start but keep it here for the moment...
library(rtdists) #to be on the safe side when loading workspace (and not executing the first chunk above)
```

## 1.2 Create Theme for Plots
```{r}
library(ggplot2)
myTheme <- theme(
  axis.line = element_line(colour = "black"), 
  panel.grid.major = element_blank(), 
  panel.grid.minor = element_blank(),  
  panel.border = element_blank(),   
  panel.background = element_blank(),
  text=element_text(size=16, colour = "black"), 
  axis.title.x = element_text(size=20, face="bold", colour = "black"), 
  axis.title.y = element_text( size=20, face="bold", colour = "black"),
  axis.text = element_text(size=16),
  strip.text =  element_text( size=16),
  strip.background = element_rect(fill = "white", colour = "black"),
  legend.background = element_rect(colour = "black"),
  legend.key = element_blank(),
  legend.key.size = unit(3, "lines"))
```

## 1.3 Load workspace (if required)
```{r}
# Load data
load("data_social_prep.RData")
```


# 2 maaDDM_sp_2w_2Phi
## 2.1 Estimate maaDDM_sp_2Phi with hierarchical Bayesian modeling (JAGS)
```{r}
# get data and initial values together and specify the model
ddmData <- list('N'=N,'S'=S,'P'=P,'H'=H,'attribute1A'=selfA,'attribute1B'=selfB,'attribute2A'=ngoA,'attribute2B'=ngoB,'RT'=RT,
                'fixProp1'=fixProp1,'fixProp2'=fixProp2,'fixProp3'=fixProp3,'fixProp4'=fixProp4)

#starting values
nChains <- 8

#parallel computing apparently not possible
T1<-Sys.time()
maaDDM2phi_sp_social <- jags.parallel(ddmData,inits = NULL,#jags.seed = sample(100:999,1),
                    parameters.to.save = c('mu_bound','sigma_bound','mu_ndt','sigma_ndt',
                                           'mu_drift','sigma_drift','mu_weight1','sigma_weight1',
                                           'mu_theta','sigma_theta','mu_phy','sigma_phy','mu_phy2','sigma_phy2','mu_sp','sigma_sp',
                                           'mu_bound_H','sigma_bound_H','mu_ndt_H','sigma_ndt_H',
                                           'mu_drift_H','sigma_drift_H','mu_weight1_H','sigma_weight1_H',
                                           'mu_theta_H','sigma_theta_H','mu_phy_H','sigma_phy_H','mu_phy2_H','sigma_phy2_H','mu_sp_H','sigma_sp_H',
                                           'bound','ndt','drift','weight1','theta','phy','phy2','sp',
                                           'bound_H','ndt_H','drift_H','weight1_H','theta_H','phy_H','phy2_H','sp_H'),
                    model.file = "BayesModel_maaDDM_sp_2Phi.txt",working.directory = 'BayesModels',
                    n.chains = nChains, n.iter = 60000, n.burnin = 30000,n.thin = 12, DIC = TRUE,jags.module = c("glm","dic","wiener"))
T2<-Sys.time() #T2-T1

# check convergence
ddmRhats <- maaDDM2phi_sp_social$BUGSoutput$summary[,8] #check with max(Rhats), which should ideally be < 1.01 (1.05 would also be okay)
max(ddmRhats)
maaDDM2phi_sp_social$BUGSoutput$DIC
# save!
save(maaDDM2phi_sp_social, file="maaDDM2phisp_social.RData")

#Rhat: 1.003; DIC: 60498.55
```

## 2.2 maaDDM_sp_2Phi: check parameters (group posteriors)
```{r}
#get group parameter estimates in transformed form
boundSep_S <- log(1+exp(maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_bound))
boundSep_H <- log(1+exp(maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_bound+maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_bound_H))
boundSep_delta <- maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_bound_H

ndt_S <- log(1+exp(maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_ndt))
ndt_H <- log(1+exp(maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_ndt+maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_ndt_H))
ndt_delta <- maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_ndt_H

drift_S <- log(1+exp(maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_drift))
drift_H <- log(1+exp(maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_drift+maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_drift_H))
drift_delta <- maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_drift_H

weight1_S <- pnorm(maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_weight1)
weight1_H <- pnorm(maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_weight1+maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_weight1_H)
weight1_delta <- maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_weight1_H

sp_S <- pnorm(maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_sp)
sp_H <- pnorm(maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_sp+maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_sp_H)
sp_delta <- maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_sp_H

theta_S <- (maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_theta)
theta_H <- (maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_theta+maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_theta_H)
theta_delta <- maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_theta_H

phy_S <- (maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_phy)
phy_H <- (maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_phy+maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_phy_H)
phy_delta <- maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_phy_H

phy2_S <- (maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_phy2)
phy2_H <- (maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_phy2+maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_phy2_H)
phy2_delta <- maaDDM2phi_sp_social$BUGSoutput$sims.list$mu_phy2_H


# PLOT 

#1) Weight 
histGran <- (-300:300)/150
# Create a data frame
datatw <- data.frame(weight1_S = weight1_S, weight1_H = weight1_H)
# Plot using ggplot2
tasteweight1<-ggplot(datatw, aes(x = weight1_S)) +
  geom_histogram(binwidth = 1/90, fill = "cornflowerblue", alpha = 0.5, color = "black") +
  geom_histogram(aes(x = weight1_H), binwidth = 1/100, fill = "gold", alpha = 0.5, color = "black") +
  labs(x = "Self Weight", y = "Frequency") +
  #scale_x_continuous(limits = c(-0.1, 0.25)) +
  ylim(0, 5000)+
  myTheme
# effect of hunger 
data_deltatw <- data.frame(weight1_delta = weight1_delta)
HDI_tw <- quantile(weight1_delta,c(.025,.975))
# Plot using ggplot2
tasteweight2<-ggplot(data_deltatw, aes(x = weight1_delta)) +
  geom_histogram(binwidth = 1/40, fill = "grey", alpha = 0.5, color = "black") +
  geom_vline(xintercept = 0, color = "red", size = 1.5) +
  geom_vline(xintercept = HDI_tw, color = "black", size = 1, linetype = "dashed") +
  ylim(0, 5000)+
  labs(x = "Effect of Hunger", y = "Frequency") +
  myTheme

HDI_ws <- quantile(weight1_S,c(.025,.975))
HDI_wh <- quantile(weight1_H,c(.025,.975))

# 2) Scaling
histGran <- (-300:300)/150
# Create a data frame
datascale <- data.frame(drift_S = drift_S, drift_H = drift_H)
# Plot using ggplot2
drift1<-ggplot(datascale, aes(x = drift_S)) +
  geom_histogram(binwidth = 1/170, fill = "cornflowerblue", alpha = 0.5, color = "black") +
  geom_histogram(aes(x = drift_H), binwidth = 1/170, fill = "gold", alpha = 0.5, color = "black") +
  labs(x = "Drift Scaling", y = "Frequency") +
  ylim(0, 5000)+
  #scale_x_continuous(limits = c(-0.1, 0.25)) +
  myTheme

# effect of hunger 
data_deltascale <- data.frame(drift_delta = drift_delta)
HDI_drift <- quantile(drift_delta,c(.025,.975))
# Plot using ggplot2
drift2<-ggplot(data_deltascale, aes(x = drift_delta)) +
  geom_histogram(binwidth = 1/70, fill = "grey", alpha = 0.5, color = "black") +
  geom_vline(xintercept = 0, color = "red", size = 1.5) +
  geom_vline(xintercept = HDI_drift, color = "black", size = 1, linetype = "dashed") +
  ylim(0, 5000)+
  labs(x = "Effect of Hunger", y = "Frequency") +
  myTheme

# 3) Starting Point
histGran <- (-300:300)/150
# Create a data frame
datasp <- data.frame(sp_S = sp_S, sp_H = sp_H)
# Plot using ggplot2
startpoint1<-ggplot(datasp, aes(x = sp_S)) +
  geom_histogram(binwidth = 1/200, fill = "cornflowerblue", alpha = 0.5, color = "black") +
  geom_histogram(aes(x = sp_H), binwidth = 1/200, fill = "gold", alpha = 0.5, color = "black") +
  labs(x = "Starting Point Bias", y = "Frequency") +
  ylim(0, 5000)+
  #scale_x_continuous(limits = c(-0.1, 0.25)) +
  myTheme

HDI_sps <- quantile(sp_S,c(.025,.975))
HDI_sph <- quantile(sp_H,c(.025,.975))

# effect of hunger 
data_deltasp <- data.frame(sp_delta = sp_delta)
HDI_sp <- quantile(sp_delta,c(.025,.975))
# Plot using ggplot2
startpoint2<-ggplot(data_deltasp, aes(x = sp_delta)) +
  geom_histogram(binwidth = 1/100, fill = "grey", alpha = 0.5, color = "black") +
  geom_vline(xintercept = 0, color = "red", size = 1.5) +
  geom_vline(xintercept = HDI_sp, color = "black", size = 1, linetype = "dashed") +
  ylim(0, 5000)+
  labs(x = "Effect of Hunger", y = "Frequency") +
  myTheme

#4) Boundary seperation
histGran <- (-300:300)/150
# Create a data frame
databound <- data.frame(boundSep_S = boundSep_S, boundSep_H = boundSep_H)
# Plot using ggplot2
bound1<-ggplot(databound, aes(x = boundSep_S)) +
  geom_histogram(binwidth = 1/30, fill = "cornflowerblue", alpha = 0.5, color = "black") +
  geom_histogram(aes(x = boundSep_H), binwidth = 1/30, fill = "gold", alpha = 0.5, color = "black") +
  labs(x = "Boundary Separation", y = "Frequency") +
  #scale_x_continuous(limits = c(-0.1, 0.25)) +
  ylim(0, 5000)+
  myTheme
# effect of hunger 
data_deltabound <- data.frame(boundSep_delta = boundSep_delta)
HDI_bound <- quantile(boundSep_delta,c(.025,.975))
# Plot using ggplot2
bound2<-ggplot(data_deltabound, aes(x = boundSep_delta)) +
  geom_histogram(binwidth = 1/40, fill = "grey", alpha = 0.5, color = "black") +
  geom_vline(xintercept = 0, color = "red", size = 1.5) +
  geom_vline(xintercept = HDI_bound, color = "black", size = 1, linetype = "dashed") +
  ylim(0, 5000)+
  labs(x = "Effect of Hunger", y = "Frequency") +
  myTheme

# 5) nDT
histGran <- (-300:300)/150
# Create a data frame
datanDT <- data.frame(ndt_S = ndt_S, ndt_H = ndt_H)
# Plot using ggplot2
nDT1<-ggplot(datanDT, aes(x = ndt_S)) +
  geom_histogram(binwidth = 1/140, fill = "cornflowerblue", alpha = 0.5, color = "black") +
  geom_histogram(aes(x = ndt_H), binwidth = 1/140, fill = "gold", alpha = 0.5, color = "black") +
  labs(x = "Non-Decision Time", y = "Frequency") +
  ylim(0, 5000)+
  #scale_x_continuous(limits = c(-0.1, 0.25)) +
  myTheme

# effect of hunger 
data_deltandt <- data.frame(ndt_delta = ndt_delta)
HDI_ndt <- quantile(ndt_delta,c(.025,.975))
# Plot using ggplot2
nDT2<-ggplot(data_deltandt, aes(x = ndt_delta)) +
  geom_histogram(binwidth = 1/100, fill = "grey", alpha = 0.5, color = "black") +
  geom_vline(xintercept = 0, color = "red", size = 1.5) +
  geom_vline(xintercept = HDI_ndt, color = "black", size = 1, linetype = "dashed") +
  ylim(0, 5000)+
  labs(x = "Effect of Hunger", y = "Frequency") +
  myTheme


# 6) Theta
histGran <- (-300:300)/150
# Create a data frame
datatheta <- data.frame(theta_S = theta_S, theta_H = theta_H)
# Plot using ggplot2
theta1<-ggplot(datatheta, aes(x = theta_S)) +
  geom_histogram(binwidth = 1/70, fill = "cornflowerblue", alpha = 0.5, color = "black") +
  geom_histogram(aes(x = theta_H), binwidth = 1/70, fill = "gold", alpha = 0.5, color = "black") +
  labs(x = "Theta", y = "Frequency") +
  ylim(0, 5000)+
  #scale_x_continuous(limits = c(-0.1, 0.25)) +
  myTheme

# effect of hunger 
data_deltatheta <- data.frame(theta_delta = theta_delta)
HDI_theta <- quantile(theta_delta,c(.025,.975))
# Plot using ggplot2
theta2<-ggplot(data_deltatheta, aes(x = theta_delta)) +
  geom_histogram(binwidth = 1/70, fill = "grey", alpha = 0.5, color = "black") +
  geom_vline(xintercept = 0, color = "red", size = 1.5) +
  geom_vline(xintercept = HDI_theta, color = "black", size = 1, linetype = "dashed") +
  ylim(0, 5000)+
  labs(x = "Effect of Hunger", y = "Frequency") +
  myTheme


# 8) Phi 1 (taste)
histGran <- (-300:300)/150
# Create a data frame
dataphy <- data.frame(phy_S = phy_S, phy_H = phy_H)
# Plot using ggplot2
phy1<-ggplot(dataphy, aes(x = phy_S)) +
  geom_histogram(binwidth = 1/25, fill = "cornflowerblue", alpha = 0.5, color = "black") +
  geom_histogram(aes(x = phy_H), binwidth = 1/25, fill = "gold", alpha = 0.5, color = "black") +
  labs(x = "Phi Self", y = "Frequency") +
  ylim(0, 5000)+
  #scale_x_continuous(limits = c(-0.1, 0.25)) +
  myTheme

# effect of hunger 
data_deltaphy <- data.frame(phy_delta = phy_delta)
HDI_phy <- quantile(phy_delta,c(.025,.975))
# Plot using ggplot2
phy2<-ggplot(data_deltaphy, aes(x = phy_delta)) +
  geom_histogram(binwidth = 1/25, fill = "grey", alpha = 0.5, color = "black") +
  geom_vline(xintercept = 0, color = "red", size = 1.5) +
  geom_vline(xintercept = HDI_phy, color = "black", size = 1, linetype = "dashed") +
  ylim(0, 5000)+
  labs(x = "Effect of Hunger", y = "Frequency") +
  myTheme

# 7) Phi2 (health)
histGran <- (-300:300)/150
# Create a data frame
dataphy2 <- data.frame(phy2_S = phy2_S, phy2_H = phy2_H)
# Plot using ggplot2
phy3<-ggplot(dataphy2, aes(x = phy2_S)) +
  geom_histogram(binwidth = 1/25, fill = "cornflowerblue", alpha = 0.5, color = "black") +
  geom_histogram(aes(x = phy2_H), binwidth = 1/25, fill = "gold", alpha = 0.5, color = "black") +
  labs(x = "Phi NGO", y = "Frequency") +
  ylim(0, 5000)+
  #scale_x_continuous(limits = c(-0.1, 0.25)) +
  myTheme

# effect of hunger 
data_deltaphy2 <- data.frame(phy2_delta = phy2_delta)
HDI_phy2 <- quantile(phy2_delta,c(.025,.975))
# Plot using ggplot2
phy4<-ggplot(data_deltaphy2, aes(x = phy2_delta)) +
  geom_histogram(binwidth = 1/25, fill = "grey", alpha = 0.5, color = "black") +
  geom_vline(xintercept = 0, color = "red", size = 1.5) +
  geom_vline(xintercept = HDI_phy2, color = "black", size = 1, linetype = "dashed") +
  ylim(0, 5000)+
  labs(x = "Effect of Hunger", y = "Frequency") +
  myTheme


library("cowplot")
# Arrange the plots side by side
combined_plot_maaddm2phi2 <- plot_grid(tasteweight1, tasteweight2, drift1, drift2, nDT1, nDT2, bound1, bound2, startpoint1, startpoint2, theta1, theta2, phy1, phy2, phy3, phy4, labels = c("a", "", "b", "", "c", "", "d", "", "e", "", "f", "", "g", "", "h", ""), label_size = 20, ncol = 4, align = "h", column_spacing = unit(c(1, 3, 1, 1, 3, 1, 1, 3, 1,1,3,1), "cm"))
combined_plot_maaddm2phi2
# Save the combined plot as a PNG file
ggsave("combined_plot_maaddm2phisp.png", combined_plot_maaddm2phi2, width = 16, height = 16)

```

# 3 Posterior predictive checks = simulate maaDDM_2Phi
## 3.1 Function
```{r}
#function for simulation (rtdists package is used to simulated the DDM)
sim_maaDDM2phi_sp  <- function(parameters,attribute1A,attribute1B,attribute2A,attribute2B,fixProps){
  
  #extract free parameters; note that order of parameters follows rtdists, not dwiener
  boundarySeparation <- parameters[1]
  ndt <- parameters[2]
  drift <- parameters[3]
  weight <- parameters[4]
  theta <- parameters[5]
  phi1 <- parameters[6] #okay to call it "phi" in R
  phi2 <- parameters[7] #okay to call it "phi" in R
  startingPoint <- parameters[8]*boundarySeparation #don't forget: sp is NOT relative in rtdists (but it is in dwiener; gosh!)
  
  #compute trial-wise value difference
  valueDifference <- fixProps[,1]*(weight*(attribute1A-theta*attribute1B)+(1-weight)*phi2*(attribute2A-theta*attribute2B))+
                     fixProps[,2]*(weight*(theta*attribute1A-attribute1B)+(1-weight)*phi2*(theta*attribute2A-attribute2B))+
                     fixProps[,3]*(weight*phi1*(attribute1A-theta*attribute1B)+(1-weight)*(attribute2A-theta*attribute2B))+
                     fixProps[,4]*(weight*phi1*(theta*attribute1A-attribute1B)+(1-weight)*(theta*attribute2A-attribute2B))

  #Simulate the DDM and store choices and RTs
  nTrials <- length(valueDifference)
  choices <- rep(NA, nTrials)
  rts <- rep(NA, nTrials)
  for (i in 1:nTrials) {
    result <- rdiffusion(1,boundarySeparation,drift*valueDifference[i],ndt,startingPoint)
    
    choices[i] <- ifelse(result$response == "upper", 2, 1)  
    rts[i] <- result$rt
  }
  simdata<-cbind(choices, rts)

    # Return the choices and RTs
  return(simdata)
}

```

## 3.2 Simulate
```{r}
#generate posterior predictives (loop over samples taken, subjects, conditions)
nPostPred <- 1000
ppSample <- sample(maaDDM2phi_sp_social$BUGSoutput$n.sims,nPostPred) #draw samples from posterior (without replacement)
ppDat_JAGS_hungry_choices <- matrix(NA, nrow = sum(H==1), ncol = nPostPred)
ppDat_JAGS_hungry_rts <- matrix(NA, nrow = sum(H==1), ncol = nPostPred)
ppDat_JAGS_sated_choices <- matrix(NA, nrow = sum(H==0), ncol = nPostPred)
ppDat_JAGS_sated_rts <- matrix(NA, nrow = sum(H==0), ncol = nPostPred)

data_social_hungry$total_dt <- data_social_hungry$selfleft_time + data_social_hungry$selfright_time + data_social_hungry$ngoleft_time + data_social_hungry$ngoright_time
data_social_sated$total_dt <- data_social_sated$selfleft_time + data_social_sated$selfright_time + data_social_sated$ngoleft_time + data_social_sated$ngoright_time

for (p in 1:nPostPred) {
  x = ppSample[p] #current sample
  simDat_JAGS_hungry <- data.frame(choices = numeric(), rts = numeric())
  simDat_JAGS_sated <- data.frame(choices = numeric(), rts = numeric())

  for (s in (unique(data_social_sated$subject))) {
    sInJAGS <- which(uID==s)
    for (t in 1:2) {
      if (t == 1){ #session-specific stuff up front; note that order of parameters follows rtdists, not dwiener
        sub <- data_social_hungry[data_social_hungry$subject == s, ] #hungry
        parameters <- c(log(1+exp(maaDDM2phi_sp_social$BUGSoutput$sims.list$bound[x,sInJAGS]+maaDDM2phi_sp_social$BUGSoutput$sims.list$bound_H[x,sInJAGS])),
                      log(1+exp(maaDDM2phi_sp_social$BUGSoutput$sims.list$ndt[x,sInJAGS]+maaDDM2phi_sp_social$BUGSoutput$sims.list$ndt_H[x,sInJAGS])),
                      log(1+exp(maaDDM2phi_sp_social$BUGSoutput$sims.list$drift[x,sInJAGS]+maaDDM2phi_sp_social$BUGSoutput$sims.list$drift_H[x,sInJAGS])),
                      pnorm(maaDDM2phi_sp_social$BUGSoutput$sims.list$weight1[x,sInJAGS]+maaDDM2phi_sp_social$BUGSoutput$sims.list$weight1_H[x,sInJAGS]),
                      (maaDDM2phi_sp_social$BUGSoutput$sims.list$theta[x,sInJAGS]+maaDDM2phi_sp_social$BUGSoutput$sims.list$theta_H[x,sInJAGS]),
                      (maaDDM2phi_sp_social$BUGSoutput$sims.list$phy[x,sInJAGS]+maaDDM2phi_sp_social$BUGSoutput$sims.list$phy_H[x,sInJAGS]),
                      (maaDDM2phi_sp_social$BUGSoutput$sims.list$phy2[x,sInJAGS]+maaDDM2phi_sp_social$BUGSoutput$sims.list$phy2_H[x,sInJAGS]), 
                      pnorm(maaDDM2phi_sp_social$BUGSoutput$sims.list$sp[x,sInJAGS]+maaDDM2phi_sp_social$BUGSoutput$sims.list$sp_H[x,sInJAGS]))
      } else {
        sub <- data_social_sated[data_social_sated$subject == s, ] #sated
        parameters <- c(log(1+exp(maaDDM2phi_sp_social$BUGSoutput$sims.list$bound[x,sInJAGS])),
                      log(1+exp(maaDDM2phi_sp_social$BUGSoutput$sims.list$ndt[x,sInJAGS])),
                      log(1+exp(maaDDM2phi_sp_social$BUGSoutput$sims.list$drift[x,sInJAGS])),
                      pnorm(maaDDM2phi_sp_social$BUGSoutput$sims.list$weight1[x,sInJAGS]),
                      (maaDDM2phi_sp_social$BUGSoutput$sims.list$theta[x,sInJAGS]),
                      (maaDDM2phi_sp_social$BUGSoutput$sims.list$phy[x,sInJAGS]),
                      (maaDDM2phi_sp_social$BUGSoutput$sims.list$phy2[x,sInJAGS]),
                      pnorm(maaDDM2phi_sp_social$BUGSoutput$sims.list$sp[x,sInJAGS]))
      }

      #arrange input data
      selfAi <- sub$self_left
      selfBi <- sub$self_right
      ntrialsi <- nrow(sub)
      #recode everything into selfish vs. prosocial choice
      selfL <- (selfAi>selfBi) #whether selfish option was left
      ngoA_s <- sub$ngo_left*(selfL==T)+sub$ngo_right*(selfL==F)
      ngoB_s <- sub$ngo_left*(selfL==F)+sub$ngo_right*(selfL==T)
      selfA_s <- sub$self_left*(selfL==T)+sub$self_right*(selfL==F)
      selfB_s <- sub$self_left*(selfL==F)+sub$self_right*(selfL==T)
      
      fixProp1_s <- sub$selfleft_time/(sub$total_dt) #self left
      fixProp2_s <- sub$selfright_time/(sub$total_dt)#self right
      fixProp3_s <- sub$ngoleft_time/(sub$total_dt)#ngo left
      fixProp4_s <- sub$ngoright_time/(sub$total_dt)#ngo right
    
      fixProps <- matrix(c(fixProp1_s*(selfL==T)+fixProp2_s*(selfL==F),fixProp1_s*(selfL==F)+fixProp2_s*(selfL==T),
                   fixProp3_s*(selfL==T)+fixProp4_s*(selfL==F),fixProp3_s*(selfL==F)+fixProp4_s*(selfL==T)),ncol=4)
      
      #rescale self and ngo values to lie between 1 and 10 (as in Yang & Krajbich)
      selfA_s <- (1+((selfA_s-min(selfA_s))*(10-1))/(max(selfA_s)-min(selfA_s)))
      selfB_s <- (1+((selfB_s-min(selfB_s))*(10-1))/(max(selfB_s)-min(selfB_s)))
      ngoA_s <- (1+((ngoA_s-min(ngoA_s))*(10-1))/(max(ngoA_s)-min(ngoA_s)))
      ngoB_s <- (1+((ngoB_s-min(ngoB_s))*(10-1))/(max(ngoB_s)-min(ngoB_s)))
      
      #take only trials with fixations
      validTrials <- which((is.na(fixProps[,1])==0)|(is.na(fixProps[,2])==0)|(is.na(fixProps[,3])==0)|(is.na(fixProps[,4])==0))
      selfA_s <- selfA_s[validTrials]
      selfB_s <- selfB_s[validTrials]
      ngoA_s <- ngoA_s[validTrials]
      ngoB_s <- ngoB_s[validTrials]
      fixProps <- fixProps[validTrials,]
      
  #simulate
      simResult <- sim_maaDDM2phi_sp(parameters, selfA_s, selfB_s, ngoA_s, ngoB_s, fixProps)
      if (t==1) {
        simDat_JAGS_hungry <- rbind(simDat_JAGS_hungry, simResult)

      } else {
        simDat_JAGS_sated <- rbind(simDat_JAGS_sated, simResult)
      }
    }  # Close t loop
  }  # Close s loop
  
  # Store the results outside the subject and condition loops
  ppDat_JAGS_hungry_choices[,p] <- simDat_JAGS_hungry[,1]
  ppDat_JAGS_hungry_rts[,p] <- simDat_JAGS_hungry[,2]
  
  ppDat_JAGS_sated_choices[,p] <- simDat_JAGS_sated[,1]
  ppDat_JAGS_sated_rts[,p] <- simDat_JAGS_sated[,2]
  
  flush.console()
  msg <- sprintf('Done with posterior predictive sample: %d', p)
  print(msg)
}  
save(ppDat_JAGS_sated_choices, ppDat_JAGS_sated_rts, ppDat_JAGS_hungry_choices, ppDat_JAGS_hungry_rts, file="ppc_social_2phisp.RData")
```


## 3.3 Preprocess sim data
```{r}
#load("ppc_social_2phisp.RData")
#execute only once!
max_sated <-mean(ppDat_JAGS_sated_rts)+4*(sd(ppDat_JAGS_sated_rts))
max_hungry<-mean(ppDat_JAGS_hungry_rts)+4*(sd(ppDat_JAGS_hungry_rts))
```

```{r}
# exclude too fast and slow responses (as done for the data)
ppDat_JAGS_hungry_choices[ppDat_JAGS_hungry_rts>max_hungry] = NA
ppDat_JAGS_hungry_choices[ppDat_JAGS_hungry_rts<.15] = NA
ppDat_JAGS_hungry_rts[ppDat_JAGS_hungry_rts>max_hungry] = NA
ppDat_JAGS_hungry_rts[ppDat_JAGS_hungry_rts<.15] = NA
ppDat_JAGS_sated_choices[ppDat_JAGS_sated_rts>max_sated] = NA
ppDat_JAGS_sated_choices[ppDat_JAGS_sated_rts<.15] = NA
ppDat_JAGS_sated_rts[ppDat_JAGS_sated_rts>max_sated] = NA
ppDat_JAGS_sated_rts[ppDat_JAGS_sated_rts<.15] = NA

# prep data
#load("data_social_prep.RData")
#a) hungry 
data_social_hungry <- data_social_hungry %>%
  mutate(choice = ifelse(
    (self_left > self_right & response == 'left') | 
    (self_left < self_right & response == 'right'),
    "selfish",
    "prosocial"
  ))

data_social_hungry<-data_social_hungry %>% 
  dplyr::mutate(choice2=dplyr::recode(choice, 'selfish'=2, 'prosocial'=1))

data_social_hungry$RT2<-data_social_hungry$RT/1000

#a) sated
data_social_sated <- data_social_sated %>%
  mutate(choice = ifelse(
    (self_left > self_right & response == 'left') | 
    (self_left < self_right & response == 'right'),
    "selfish",
    "prosocial"
  ))

data_social_sated<-data_social_sated %>% 
  dplyr::mutate(choice2=dplyr::recode(choice, 'selfish'=2, 'prosocial'=1))


data_social_sated$RT2<-data_social_sated$RT/1000

```


```{r}
# Convert matrices to dataframe
sim_dataframe_hungry <- data.frame(
  RT = as.vector(ppDat_JAGS_hungry_rts),
  choice = as.vector(ppDat_JAGS_hungry_choices),
  simulation = rep(1:ncol(ppDat_JAGS_hungry_rts), each = nrow(ppDat_JAGS_hungry_rts))
)

sim_dataframe_sated <- data.frame(
  RT = as.vector(ppDat_JAGS_sated_rts),
  choice = as.vector(ppDat_JAGS_sated_choices),
  simulation = rep(1:ncol(ppDat_JAGS_sated_rts), each = nrow(ppDat_JAGS_sated_rts))
)



# Modified function to create plots without title
plot_mirrored_histogram_ci <- function(observed_data, sim_dataframe, bins = 30, show_legend = TRUE) {
  
  # Process choice 2 (upper, positive)
  obs_data_2 <- observed_data %>% 
    filter(choice2 == 2, is.finite(RT2), RT2 > 0)
  sim_data_2 <- sim_dataframe %>% 
    filter(choice == 2, is.finite(RT), RT > 0)
  
  # Process choice 1 (lower, negative)
  obs_data_1 <- observed_data %>% 
    filter(choice2 == 1, is.finite(RT2), RT2 > 0)
  sim_data_1 <- sim_dataframe %>% 
    filter(choice == 1, is.finite(RT), RT > 0)
  
  # Create common bin edges
  all_rt <- c(obs_data_2$RT2, obs_data_1$RT2, sim_data_2$RT, sim_data_1$RT)
  rt_range <- range(all_rt, na.rm = TRUE)
  bin_edges <- seq(rt_range[1], rt_range[2], length.out = bins + 1)
  bin_centers <- (bin_edges[-1] + bin_edges[-length(bin_edges)]) / 2
  
  # Function to get CI for one choice
  get_choice_ci <- function(obs_data, sim_data, flip = FALSE) {
    # Observed histogram
    obs_hist <- hist(obs_data, breaks = bin_edges, plot = FALSE)
    
    # CI calculation
    ci_results <- data.frame()
    for(i in 1:length(bin_centers)) {
      bin_start <- bin_edges[i]
      bin_end <- bin_edges[i + 1]
      
      sim_counts <- sim_data %>%
        filter(RT >= bin_start & RT < bin_end) %>%
        group_by(simulation) %>%
        summarise(count = n(), .groups = 'drop')
      
      all_sims <- data.frame(simulation = 1:max(sim_data$simulation))
      sim_counts <- merge(all_sims, sim_counts, all.x = TRUE)
      sim_counts$count[is.na(sim_counts$count)] <- 0
      
      ci <- hdi(sim_counts$count, credMass = 0.95)
      print(ci)
      
      ci_results <- rbind(ci_results, data.frame(
        bin_center = bin_centers[i],
        observed = obs_hist$counts[i],
        ci_lower = if(flip) -ci[2] else ci[1],
        ci_upper = if(flip) -ci[1] else ci[2]
      ))
    }
    
    if(flip) {
      ci_results$observed <- -ci_results$observed
    }
    
    return(ci_results)
  }
  
  # Get data for both choices
  choice2_data <- get_choice_ci(obs_data_2$RT2, sim_data_2, flip = FALSE)
  choice1_data <- get_choice_ci(obs_data_1$RT2, sim_data_1, flip = TRUE)
  print(choice2_data)

  
  # Create the plot
  p <- ggplot() +
    # Choice 2 (upper) - Selfish
    geom_col(data = choice2_data,
             aes(x = bin_center, y = observed, fill = "Selfish (data)"),
             width = diff(bin_edges)[1] * 0.8,
             color = "black", alpha = 0.7) +
    geom_ribbon(data = choice2_data, 
                aes(x = bin_center, ymin = ci_lower, ymax = ci_upper, fill = "95% CI (simulated)"), 
                alpha = 0.9) +
    
    # Choice 1 (lower, flipped) - Prosocial
    geom_col(data = choice1_data,
             aes(x = bin_center, y = observed, fill = "Prosocial (data)"),
             width = diff(bin_edges)[1] * 0.8,
             color = "black", alpha = 0.7) +
    geom_ribbon(data = choice1_data, 
                aes(x = bin_center, ymin = ci_lower, ymax = ci_upper, fill = "95% CI (simulated)"), 
                alpha = 0.9) +
    
    # Manual color scale for legend
    scale_fill_manual(
      name = "Choice",
      values = c("Selfish (data)" = "darkgrey", 
                 "Prosocial (data)" = "white", 
                 "95% CI (simulated)" = "orange"),
      breaks = c("Selfish (data)", "Prosocial (data)", "95% CI (simulated)")
    ) +

    
    # Styling
    geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
    labs(
      x = "Response Time (s)", 
      y = "Frequency"
    ) +
    myTheme +
    xlim(0, 10) +
    coord_cartesian(ylim = c(-1200, 750))+
    # Make y-axis labels show absolute values (positive)
    scale_y_continuous(labels = abs) 
    

    
  # Control legend display
  if (!show_legend) {
    p <- p + theme(legend.position = "none")
  }
  
  return(p)
}

# Create individual plots with colored frames (excluding legend area)
plot_a <- plot_mirrored_histogram_ci(data_social_hungry, sim_dataframe_hungry, bins = 120, show_legend = TRUE) +
  ggtitle("a) Hungry") +
  theme(panel.background = element_rect(color = "gold", linewidth = 2, fill = NA),
        plot.margin = margin(10, 10, 20, 10))

plot_b <- plot_mirrored_histogram_ci(data_social_sated, sim_dataframe_sated, bins = 90, show_legend = TRUE) +
  ggtitle("b) Sated") +
  theme(panel.background = element_rect(color = "cornflowerblue", linewidth = 2, fill = NA),
        plot.margin = margin(10, 10, 20, 10))

# Combine plots using patchwork with shared legend at bottom and more space
library(patchwork)
combined_plot <- (plot_a | plot_b) + 
                 plot_layout(guides = "collect") &
                 theme(legend.position = "bottom")

# Print the combined plot
print(combined_plot)

#ggsave("ppc_social.png", combined_plot, width = 12, height = 7)
```






