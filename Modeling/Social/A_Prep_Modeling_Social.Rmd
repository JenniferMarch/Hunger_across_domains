---
title: "Prep Discount Model"
output: html_document
date: "2024-10-09"
---

# General Info
This script contains loading data and preprocessing it for all modeling analyses. Crucially (and different to preprocesing in the behavioural analyses), we change the format of fixations in 2.3 and set some parameters in 3 this results in data_prep.RData

Note: 09.10 Fixing preprocessing as I forgot to preprocess RT <250 for data_hungry long (also for social task. This should be fix the error); remember to update Git!

### 1 Preperations
#### 1.1 Load Data
```{r}
#clear working environment
rm(list=ls())

#clear all plots
if(!is.null(dev.list())) dev.off()

load("discount_modeling_data.RData")
#load("food_data.RData")

#check what happened to this one participant in the trial based file!
data_discount_hungry_long <- subset(data_discount_hungry_long, subject %in% data_discount_sated$subject)
data_discount_sated_long <- subset(data_discount_sated_long, subject %in% data_discount_hungry$subject)
data_discount_hungry_long <- subset(data_discount_hungry_long, subject %in% data_discount_hungry$subject)
data_discount_sated_long <- subset(data_discount_sated_long, subject %in% data_discount_sated$subject)

data_discount_hungry<- subset(data_discount_hungry, subject %in% data_discount_hungry_long$subject)
data_discount_sated <- subset(data_discount_sated, subject %in% data_discount_sated_long$subject)

length(unique(data_discount_hungry$subject))
length(unique(data_discount_sated_long$subject))
```


## 2.3 Get fixations in correct format
### 2.3.1 hungry
```{r}
library(tidyr)
library(dplyr)

# Set seed for reproducibility
set.seed(123)
# Add random noise -necessary, bc otherwise some trials cannot be uniquely identified
data_discount_hungry_long$fixdur <- data_discount_hungry_long$fixdur + runif(nrow(data_discount_hungry_long), 0.0001, 0.001)

expanded_table_h <- vector("list", length(unique(data_discount_hungry_long$subject)))

for (s in unique(data_discount_hungry_long$subject)) {
  testsub <- data_discount_hungry_long[data_discount_hungry_long$subject == s, ]

  fixatedElement <- testsub[c("trial", "fixElement", "fixdur")]

  fixatedElement$totaldur <- fixatedElement$fixdur
  for (i in 2:nrow(fixatedElement)) {
    if (fixatedElement$trial[i] == fixatedElement$trial[i-1]) {
      fixatedElement$totaldur[i] <- fixatedElement$fixdur[i] + fixatedElement$totaldur[i-1]
    }
  }

  fixtab <- fixatedElement[c("trial", "fixElement", "totaldur")]

  expanded_table_h[[s]] <- fixtab %>%
    group_by(trial) %>%
    fill(fixElement) %>%
    mutate(totaldur = lag(totaldur, default = 0) + 1) %>%
    fill(fixElement) %>%
    complete(totaldur = 1:10000) %>%
    fill(fixElement, .direction = "down") %>%
    ungroup()

  # Pivot the table to match the desired structure
  expanded_table_h[[s]] <- pivot_wider(expanded_table_h[[s]], names_from = trial, values_from = fixElement)
  expanded_table_h[[s]] <- expanded_table_h[[s]] %>%
    dplyr::select(-1)
}
# Filter out empty tables from the list
expanded_table_h <- expanded_table_h[sapply(expanded_table_h, length) > 0]

```

### 2.3.2 sated
```{r}
# Set seed for reproducibility
set.seed(123)
# Add random noise -necessary, bc otherwise some trials cannot be uniquely identified
data_discount_sated_long$fixdur <- data_discount_sated_long$fixdur + runif(nrow(data_discount_sated_long), 0.0001, 0.001)

expanded_table_s <- vector("list", length(unique(data_discount_sated_long$subject)))

for (s in unique(data_discount_sated_long$subject)) {
  testsub <- data_discount_sated_long[data_discount_sated_long$subject == s, ]

  fixatedElement <- testsub[c("trial", "fixElement", "fixdur")]

  fixatedElement$totaldur <- fixatedElement$fixdur
  for (i in 2:nrow(fixatedElement)) {
    if (fixatedElement$trial[i] == fixatedElement$trial[i-1]) {
      fixatedElement$totaldur[i] <- fixatedElement$fixdur[i] + fixatedElement$totaldur[i-1]
    }
  }

  fixtab <- fixatedElement[c("trial", "fixElement", "totaldur")]

  expanded_table_s[[s]] <- fixtab %>%
    group_by(trial) %>%
    fill(fixElement) %>%
    mutate(totaldur = lag(totaldur, default = 0) + 1) %>%
    fill(fixElement) %>%
    complete(totaldur = 1:10000) %>%
    fill(fixElement, .direction = "down") %>%
    ungroup()

  # Pivot the table to match the desired structure
  expanded_table_s[[s]] <- pivot_wider(expanded_table_s[[s]], names_from = trial, values_from = fixElement)
  expanded_table_s[[s]] <- expanded_table_s[[s]] %>%
    dplyr::select(-1)
}
# Filter out empty tables from the list
expanded_table_s <- expanded_table_s[sapply(expanded_table_s, length) > 0]

```

## 2.4 Set some parameters
```{r}
# #loop over subjects for individual fits
# nFits <- 10 #number of attempts to fit per subject
# nsubj<- length(unique(data_discount_hungry$subject)) #doesn't matter whether taking hungry or sated 
# ntrials<-190
# dt <- 1/1000
# paramNames <- c('boundarySeparation','driftScaling','ndt','weight','theta','phi')
# nParams <- length(paramNames)
# bestDevianceH <- rep(-2*ntrials*log(1e-5),nsubj) #start with a very high deviance)
# allDeviancesH <- data.frame(matrix(bestDevianceH[1],nrow = nsubj,ncol = nFits))
# bestParametersH <- data.frame(matrix(nrow = nsubj,ncol = nParams))
# colnames(bestParametersH) <- paramNames
# allParametersH <- array(NA,c(nFits,nParams,nsubj))
# bestDevianceS <- bestDevianceH
# allDeviancesS <- allDeviancesH
# bestParametersS <- bestParametersH
# allParametersS <- allParametersH
# 
```


# 3 hierarchical Bayesian modeling (JAGS) - preparation
```{r}
#loop over subjects to get the data and arrange it in the order needed
uID <- unique(data_discount_hungry$subject)
#value - time data
valueA <- c()
valueB <- c()
timeA <- c()
timeB <- c()

fixProp1 <- c()
fixProp2 <- c()
fixProp3 <- c()
fixProp4 <- c()
RT <- c()

H <- c() #whether trial is hungry (1) or sated (0)
P <- c() #participant number (from 1 till nsubj, so 1, 2, 3, 4, ..., nsubj)

blubb <- matrix(NA,nrow=max(uID),ncol=2) # check if fixation props are correct
dt <- 1/1000

for (s in (unique(data_discount_hungry$subject))){
  
  #loop over sessions (1 = hungry)
  for (t in 1:2){
    if (t == 1){ #session-specific stuff up front
      sub <- data_discount_hungry[data_discount_hungry$subject == s, ] #hungry
      fixatedElement <- expanded_table_h[[which(unique(data_discount_hungry$subject)==s)]]
    } else {
      sub <- data_discount_sated[data_discount_sated$subject == s, ] #sated
      fixatedElement <- expanded_table_s[[which(unique(data_discount_sated$subject)==s)]]
    }
    
    #rearrange input data for value -time Choice
    valueL <- (sub$value_left<sub$value_right) #whether impatient choice was left
    response <- sub$response
    response <- as.numeric(((response==("left"))&(valueL==T))|((response==("right"))&(valueL==F)))
    rt_s <- sub$RT*dt
    rt_s[response==0] = -rt_s[response==0] #dwiener function in JAGS wants "negative" rt if choice == 0

    valueA_s <- sub$value_left*(valueL==T)+sub$value_right*(valueL==F)
    valueB_s <- sub$value_left*(valueL==F)+sub$value_right*(valueL==T)
    timeA_s <- sub$time_left*(valueL==T)+sub$time_right*(valueL==F)
    timeB_s <- sub$time_left*(valueL==F)+sub$time_right*(valueL==T)

    #prepare fixation data value - time
    ntrialsi <- nrow(sub)
    fixProps <- matrix(nrow = ntrialsi,ncol = 4)
    for (n in 1:ntrialsi){
      fEn <- fixatedElement[1:round(sub$RT[n]),n] #stream of fixated elements in current trials
      fixProps[n,] <- c(sum(na.omit(fEn==1)),sum(na.omit(fEn==2)),sum(na.omit(fEn==3)),sum(na.omit(fEn==4)))/sum(na.omit(fEn>=1))
    }
    fixProps <- matrix(c(fixProps[,1]*(valueL==T)+fixProps[,2]*(valueL==F),fixProps[,1]*(valueL==F)+fixProps[,2]*(valueL==T),
                   fixProps[,3]*(valueL==T)+fixProps[,4]*(valueL==F),fixProps[,3]*(valueL==F)+fixProps[,4]*(valueL==T)),ncol=4)

    
    #fill in "all-subject" vectors for value time
    valueA <- c(valueA,valueA_s)
    valueB <- c(valueB,valueB_s)
    timeA <- c(timeA,timeA_s)
    timeB <- c(timeB,timeB_s)

    fixProp1 <- c(fixProp1,fixProps[,1])
    fixProp2 <- c(fixProp2,fixProps[,2])
    fixProp3 <- c(fixProp3,fixProps[,3])
    fixProp4 <- c(fixProp4,fixProps[,4])
    RT <- c(RT,rt_s)
    H <- c(H,rep(t==1,length(rt_s)))
    P <- c(P,rep(which(uID==s),length(rt_s)))
    
    bla=cor.test(as.numeric(fixProps[,1]-fixProps[,2]+fixProps[,3]-fixProps[,4]),as.numeric(rt_s>0))
    blubb[s,t]=bla$estimate
    
  }
}

#rescale value and nutri values to lie between 1 and 10 (as in Yang & Krajbich), in line with Berkowitsch et al. 2015
valueA <- (1+((valueA-min(valueA))*(10-1))/(max(valueA)-min(valueA))) 
valueB <- (1+((valueB-min(valueB))*(10-1))/(max(valueB)-min(valueB)))
timeA <- (1+((timeA-min(timeA))*(10-1))/(max(timeA)-min(timeA)))
timeB <- (1+((timeB-min(timeB))*(10-1))/(max(timeB)-min(timeB)))

#reverse rating order so higher is better 
timeA2 <- max(timeA)-timeA
timeB2 <- max(timeB)-timeB

#take only trials with fixations
validT <- which((is.na(fixProp1)==0)|(is.na(fixProp2)==0)|(is.na(fixProp3)==0)|(is.na(fixProp4)==0))
valueA <- valueA[validT]
valueB <- valueB[validT]
timeA <- timeA[validT]
timeB <- timeB[validT]
fixProp1 <- fixProp1[validT]
fixProp2 <- fixProp2[validT]
fixProp3 <- fixProp3[validT]
fixProp4 <- fixProp4[validT]
RT <- RT[validT]
H <- H[validT]
P <- P[validT]
N <- length(RT)
S <- length(unique(data_discount_hungry$subject))

```

wondering if there is something wrong with the fixations... is

```{r}
save.image('data_discount_prep.RData')
```