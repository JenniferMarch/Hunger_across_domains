---
title: "Hunger Across Domains - Behavioural Analyses"
author: "Jennifer March (jennifer.march@uni-hamburg.de)"
date: "2024-06-11"
output: html_document
---

### Information
This script contains the behavioural analyses of food choice, social choice and discounting task, that is GLMMs.
**Requirements** had_data.RData 
**Output** had_data.RData; Figure 2, Figure S4, S5, S6 as well as stats (GLMM, mediation and t-test)

## 1 Preperations
### 1.1 Load Libraries
```{r}
#clear working environment
#rm(list=ls())

#load required libraries
library(readxl)
library(ggpubr)
library(rstatix)
library(readr)
library(tidyr)
library(dplyr)
library(zoo)
library (ggplot2)
library(tibble)
#library(rstatix)
library(tidyverse)
library(Matrix)
library(ez)
library(car)
library(lme4)
library(lmerTest)

```

### 1.2 Chreate Theme for figures
```{r}
myTheme <- theme(
  axis.line = element_line(colour = "black"), 
  panel.grid.major = element_blank(), 
  panel.grid.minor = element_blank(),  
  panel.border = element_blank(),   
  panel.background = element_blank(),
  text=element_text(size=16, colour = "black"), 
  axis.title.x = element_text(size=20, face="bold", colour = "black"), 
  axis.title.y = element_text( size=20, face="bold", colour = "black"),
  axis.text = element_text(size=16),
  strip.text =  element_text( size=16),
  strip.background = element_rect(fill = "white", colour = "black"),
  legend.background = element_rect(colour = "black"),
  legend.key = element_blank(),
  legend.key.size = unit(3, "lines"))
```

### 1.3 Load Pre-processed Data
```{r}
load('had_data.RData')

data_combined2 <- subset(data_combined,rel_dwelldiff_chosen!='NaN')
data_combined_social2 <- subset(data_social_combined,rel_dwelldiff_chosen!='NaN')
data_combined_discount2 <- subset(data_discount_combined,rel_dwelldiff_chosen!='NaN')
data_combined_discount2 <- subset(data_combined_discount2, RT <30000) #  even though I excluded RTs more than 4SD bigger than the mean, there is one RT of 31 seconds which causes convergence issues of the RT GLMM, so rather than simplifying the model, we decided to exclude this trial for comparability between tasks 
```


## 2 Behavioural Analyses
Hypothesis 1: 	Hunger state affects value-based choice across domains. 
### 2.1 Food Choice
a)	We predict that hungrier participants are more likely to choose tasty over healthy foods. This will also be reflected in shorter response times towards tasty food options in the hungry condition. 
#### 2.1.1 Preperation 
Is Random effects justified?
```{r}
data_combined2 <- data_combined2 %>%
  dplyr::mutate(choice2 = dplyr::recode(as.character(choice), "taste" = 1, "health" = 0))

data_combined2<-data_combined2 %>% 
  dplyr::mutate(response2=dplyr::recode(response, 'left'=1, 'right'=0))

#is random effects justified?
food_model0 <- glm(choice2~1, data=data_combined2, family=binomial)
food_model1 <- glmer(choice2~(1|subject), data=data_combined2, family=binomial, control = glmerControl(optimizer = "bobyqa"))
food_model2 <- glmer(choice2~(1+condition|subject), data=data_combined2, family=binomial, , control = glmerControl(optimizer = "bobyqa"))

aic_glm <- AIC(logLik(food_model0))
aic_glmer1 <- AIC(logLik(food_model1))
aic_glmer2 <- AIC(logLik(food_model2))

aic_glm
aic_glmer1
aic_glmer2
# AIC of random effects model smaller, hence better
```

add rel. dwell time difference tasty - healthy option
```{r}
# relative dwell time tasty option
data_combined2$dwelldiff_taste_rel <- 0
for (i in 1:nrow(data_combined2)){
  if((data_combined2$choice2[i]==1) && (data_combined2$response2[i]==1)) { # taste & left
    data_combined2$dwelldiff_taste_rel[i] = ((data_combined2$foodleft_time[i]+data_combined2$nutrileft_time[i]) - (data_combined2$foodright_time[i]+data_combined2$nutriright_time[i]))/(data_combined2$foodright_time[i]+data_combined2$nutriright_time[i]+data_combined2$foodleft_time[i]+data_combined2$nutrileft_time[i])
  }else if ((data_combined2$choice2[i]==1) && (data_combined2$response2[i]==0)) { # taste & right
    data_combined2$dwelldiff_taste_rel[i] = ((data_combined2$foodright_time[i]+data_combined2$nutriright_time[i])- (data_combined2$foodleft_time[i]+data_combined2$nutrileft_time[i]))/(data_combined2$foodleft_time[i]+data_combined2$nutrileft_time[i]+data_combined2$foodright_time[i]+data_combined2$nutriright_time[i])
  }else if ((data_combined2$choice2[i]==0) && (data_combined2$response2[i]==1)) { # health & left
    data_combined2$dwelldiff_taste_rel[i] = ((data_combined2$foodright_time[i]+data_combined2$nutriright_time[i])-(data_combined2$foodleft_time[i]+data_combined2$nutrileft_time[i]))/(data_combined2$foodleft_time[i]+data_combined2$nutrileft_time[i]+data_combined2$foodright_time[i]+data_combined2$nutriright_time[i])
  }else if ((data_combined2$choice2[i]==0) && (data_combined2$response2[i]==0)) { # health & right
    data_combined2$dwelldiff_taste_rel[i] = ((data_combined2$foodleft_time[i]+data_combined2$nutrileft_time[i])-(data_combined2$foodright_time[i]+data_combined2$nutriright_time[i]))/(data_combined2$foodright_time[i]+data_combined2$nutriright_time[i]+data_combined2$foodleft_time[i]+data_combined2$nutrileft_time[i])
  }
}


# relative dwell time taste attributes
data_combined2$rel_dwelldiff_th <- ((data_combined2$foodleft_time+data_combined2$foodright_time) - (data_combined2$nutrileft_time+data_combined2$nutriright_time)) / (data_combined2$foodleft_time+data_combined2$foodright_time + data_combined2$nutrileft_time+data_combined2$nutriright_time)

#almost no time at nutri, so I am plotting looking at choice probability of trials where Nutriscore was fixated vs not fixated
data_combined2$nutri <- ifelse((data_combined2$nutrileft_time >0 |data_combined2$nutriright_time >0), 0, 1) # coded as not=1 and fixated = 0 so it fits with the notion of hot vs cold attribute (Used for plotting Figure 2 a)

data_combined2$gender2  <- ifelse((data_combined2$gender == "Weiblich"), 1, 0)
unique(data_combined2$gender2)


# scale by participant

data_combined2 <- data_combined2 %>%
  group_by(subject) %>%
  mutate(scl_dwelldiff_taste_rel = scale(dwelldiff_taste_rel)[,1]) 
```

#### 2.1.2 Choice Models
```{r}
data_combined2$condition <- relevel(factor(data_combined2$condition), ref = "sated")
# Model Main
food_model5 <- glmer(choice2~condition + scl_dwelldiff_taste_rel + nutri + (1+condition|subject), data=data_combined2, family=binomial(link="logit"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
# Model add predictors (less participants!)
food_model8 <- glmer(choice2~condition + scl_dwelldiff_taste_rel + nutri + (gender2) + BMI_cent + age_cent + PA_change + NA_change + hs_change + external + emotional + restricted + (1+condition|subject), data=data_combined2, family=binomial(link="logit"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))


summary(food_model5)
summary(food_model8)

CIf5 <-confint(food_model5, method = "Wald")
CIF8<-confint(food_model8, method = "Wald")
CIf5
CIF8
```

#### 2.1.3 RT
```{r}
food_RTmodel0 <- glm(RT/1000~1, data=data_combined2,family=Gamma(link="identity"))
food_RTmodel1 <- glmer(RT/1000~(1|subject), data=data_combined2,family=Gamma(link="identity"))
food_RTmodel2 <- glmer(RT/1000~(1+condition|subject), data=data_combined2,family=Gamma(link="identity"))
aic_glm <- AIC(logLik(food_RTmodel0))
aic_glmer <- AIC(logLik(food_RTmodel1))
aic_glmer2 <- AIC(logLik(food_RTmodel2))
aic_glm
aic_glmer
aic_glmer2

food_modelRT3 <- glmer(RT/1000 ~ condition * choice2 + (1+condition|subject), data=data_combined2, family=Gamma(link="identity"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
summary(food_modelRT3)

CIfRT <-confint(food_modelRT3, method = "Wald")
CIfRT
```

#### 2.1.4 Mediation
```{r}
library(bmlm)
library(qgraph) # for graph necessary
data_combined2<-isolate(d=data_combined2, by="subject", value="scl_dwelldiff_taste_rel")

# necessary for model
data_combined2$condition2 <- ifelse(data_combined2$condition == "hungry", 1, 0)

mediation<-mlm(d=data_combined2, id="subject", x="condition2", m="scl_dwelldiff_taste_rel_cw", y="choice2", iter=50000, warmup=25000, cores=4, binary_y = TRUE)
mlm_summary(mediation)
mlm_summary(mediation,pars="random")
mlm_path_plot(mediation, xlab = "condition", mlab="attention", ylab="food choice")
```


### 2.2 Social
We predict a substantial spillover effect of hunger state on social decisions, that is, hungry participants are more likely to choose in line with their idiosyncratic tendencies (i.e., egoistic individuals are more likely to choose egoistic options in a hungry compared to a satiated state and altruistic individuals are more likely to choose an altruistic option in a hungry compared to a satiated state). This will also be reflected in shorter response times towards participants idiosyncratic preference in the hungry condition.

For manuscript we deviate from this hypothesis to make the effect of hunger on choice variable comparable
#### 2.2.1 Preparation 
Is Random effects justified?
```{r}
data_combined_social2 <- data_combined_social2 %>%
  mutate(choice = ifelse(
    (self_left > self_right & response == 'left') | 
    (self_left < self_right & response == 'right'),
    "selfish",
    "prosocial"
  ))

data_combined_social2 <- data_combined_social2 %>%
  mutate(choice2 = case_when(
    choice == "selfish" ~ 1,
    choice == "prosocial" ~ 0,
    TRUE ~ NA_real_  # Handle other cases, if any
  ))

data_combined_social2 <- data_combined_social2 %>%
  mutate(response2 = case_when(
    response == "left" ~ 1,
    response == "right" ~ 0,
    TRUE ~ NA_real_  # Handle other cases, if any
  ))


data_combined_social2$gender2  <- ifelse((data_combined_social2$gender == "Weiblich"), 1, 0)

#is random effects justified?
social_model0 <- glm(choice2~1, data=data_combined_social2, family=binomial)
social_model1 <- glmer(choice2~(1|subject), data=data_combined_social2, family=binomial, control = glmerControl(optimizer = "bobyqa"))
social_model2 <- glmer(choice2~(1+condition|subject), data=data_combined_social2, family=binomial, , control = glmerControl(optimizer = "bobyqa"))

AIC(logLik(social_model0))
AIC(logLik(social_model1))
AIC(logLik(social_model2))

# AIC of random effects model smaller, hence better
```

add rel. dwell time difference selfish - prosocial option
```{r}
# #recode ngo/value 
data_combined_social2$total_dt <- data_combined_social2$ngoleft_time+data_combined_social2$selfleft_time+data_combined_social2$ngoright_time+data_combined_social2$selfright_time
data_combined_social2$dwelldiff_time <- 0
data_combined_social2$dwelldiff_rel_time <- 0

for (i in 1:nrow(data_combined_social2)){

  if((data_combined_social2$choice2[i]==1) && (data_combined_social2$response2[i]==1)) { # self & left
    data_combined_social2$dwelldiff_time[i] = (data_combined_social2$ngoleft_time[i]+data_combined_social2$selfleft_time[i])-(data_combined_social2$ngoright_time[i]+data_combined_social2$selfright_time[i])
    data_combined_social2$dwelldiff_rel_time[i] = ((data_combined_social2$ngoleft_time[i]+data_combined_social2$selfleft_time[i])-(data_combined_social2$ngoright_time[i]+data_combined_social2$selfright_time[i]))/data_combined_social2$total_dt[i]
    
  }else if ((data_combined_social2$choice2[i]==1) && (data_combined_social2$response2[i]==0)) { # self & right
    data_combined_social2$dwelldiff_time[i] = (data_combined_social2$ngoright_time[i]+data_combined_social2$selfright_time[i])-(data_combined_social2$ngoleft_time[i]+data_combined_social2$selfleft_time[i])
    data_combined_social2$dwelldiff_rel_time[i] = ((data_combined_social2$ngoright_time[i]+data_combined_social2$selfright_time[i])-(data_combined_social2$ngoleft_time[i]+data_combined_social2$selfleft_time[i]))/data_combined_social2$total_dt[i]
    
  }else if ((data_combined_social2$choice2[i]==0) && (data_combined_social2$response2[i]==1)) { # ngo & left
    data_combined_social2$dwelldiff_time[i] = (data_combined_social2$ngoright_time[i]+data_combined_social2$selfright_time[i])-(data_combined_social2$ngoleft_time[i]+data_combined_social2$selfleft_time[i])
    data_combined_social2$dwelldiff_rel_time[i] = ((data_combined_social2$ngoright_time[i]+data_combined_social2$selfright_time[i])-(data_combined_social2$ngoleft_time[i]+data_combined_social2$selfleft_time[i]))/data_combined_social2$total_dt[i]
    
  }else if ((data_combined_social2$choice2[i]==0) && (data_combined_social2$response2[i]==0)) { # ngo & right
    data_combined_social2$dwelldiff_time[i] = (data_combined_social2$ngoleft_time[i]+data_combined_social2$selfleft_time[i])-(data_combined_social2$ngoright_time[i]+data_combined_social2$selfright_time[i])
    data_combined_social2$dwelldiff_rel_time[i] = ((data_combined_social2$ngoleft_time[i]+data_combined_social2$selfleft_time[i])-(data_combined_social2$ngoright_time[i]+data_combined_social2$selfright_time[i]))/data_combined_social2$total_dt[i]
  }
} 

data_combined_social2$rel_dwelldiff_self2 <- ((data_combined_social2$selfleft_time+data_combined_social2$selfright_time) - (data_combined_social2$ngoleft_time+data_combined_social2$ngoright_time)) /data_combined_social2$total_dt


data_combined_social2 <- data_combined_social2 %>%
  group_by(subject) %>%
  mutate(scl_dwelldiff_rel_time = scale(dwelldiff_rel_time)[,1],
         scl_rel_dwelldiff_self2 = scale(rel_dwelldiff_self2)[,1]
         ) %>%
  ungroup()

```

#### 2.2.2 Choice Models

```{r}
data_combined_social2$condition <- relevel(factor(data_combined_social2$condition), ref = "sated")
social_model3 <- glmer(choice2 ~ condition + scl_dwelldiff_rel_time + scl_rel_dwelldiff_self2 + (1 + condition | subject), data = data_combined_social2, family = binomial(link = "logit"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
summary(social_model3)


# Problem: How can looking longer at the selfish attribute predict actually prosocial choice (on average)??
# Investigate this for all subjects

# models for each participant and condition to get slopes
slope_data <- data_combined_social2 %>%
  group_by(subject, condition) %>%
  do(model = glm(choice2 ~ rel_dwelldiff_self2, data = ., family = binomial)) %>% # no scaling for illustration purposes
  mutate(slope = coef(model)[2]) 


# Order based on overall slope (across conditions)
slope_summary <- slope_data %>%
  group_by(subject) %>%
  summarize(avg_slope = mean(slope, na.rm = TRUE)) %>%
  arrange(avg_slope)  # From most negative to most positive

# Create ordered factor for subject based on calculated slopes
data_combined_social2$subject_ordered <- factor(
  data_combined_social2$subject,
  levels = slope_summary$subject
)

# Plot
p_raw <- ggplot(data_combined_social2,
                aes(x = (rel_dwelldiff_self2), y = choice2, color = condition)) +
  geom_smooth(method = "glm", method.args = list(family=binomial), se = TRUE,
              aes(fill = condition), alpha = 0.2, linewidth=0.7) +
  geom_point(size=0.8, alpha=0.6) +
  facet_wrap(~subject_ordered, nrow=8) +
  scale_color_manual(values = c("gold", "cornflowerblue")) +
  scale_fill_manual(values = c("gold", "cornflowerblue")) +
labs(x = expression(bold(paste("DT", Delta, "(attribute"[paste("self")], " - attribute"[paste("NGO")], ")"))), y = "P(Selfish Choice)") +
  geom_hline(yintercept = 0.5, color = "black", linetype = "dashed", linewidth=0.5) +
  geom_vline(xintercept = 0, color = "black", linetype = "dashed", linewidth=0.5) +
  ylim(0,1) +
  theme_minimal() +
  theme(
    strip.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.spacing = unit(0.3, "lines"),
    legend.position = "bottom"
  )

ggsave("subject_facets_ordered_by_slope.png", plot = p_raw, width = 10, height = 12, dpi = 300)

```

```{r}
# Given the large variation we should take rel DT on the self attribute adding it as a random slope effect (allowing subject slope to vary)
social_model4 <- glmer(choice2 ~ condition + scl_dwelldiff_rel_time + scl_rel_dwelldiff_self2 + (1 + condition + scl_rel_dwelldiff_self2| subject), data = data_combined_social2, family = binomial(link = "logit"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
summary(social_model4)

# add demographics and questionnaire scores
social_model5 <- glmer(choice2~condition + (scl_dwelldiff_rel_time) + (scl_rel_dwelldiff_self2) + (gender2) + BMI_cent + age_cent + (PA_change) + (NA_change)+ (hs_change) + (external) + (emotional) + (restricted) + (1 + condition + scl_rel_dwelldiff_self2| subject), data=data_combined_social2, family=binomial(link="logit"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))


summary(social_model5)

CIs4 <-confint(social_model4, method = "Wald")
CIs5<-confint(social_model5, method = "Wald")
CIs4
CIs5

```



#### 2.2.3 Response Time Model
```{r}
social_RTmodel0 <- glm(RT/1000~1, data=data_combined_social2,family=Gamma(link="identity"))
social_RTmodel1 <- glmer(RT/1000~(1|subject), data=data_combined_social2,family=Gamma(link="identity"))
social_RTmodel2 <- glmer(RT/1000~(1+condition|subject), data=data_combined_social2,family=Gamma(link="identity"))
aic_glm <- AIC(logLik(social_RTmodel0))
aic_glmer <- AIC(logLik(social_RTmodel1))
aic_glmer2 <- AIC(logLik(social_RTmodel2))
aic_glm
aic_glmer
aic_glmer2

social_modelRT3 <- glmer(RT/1000~condition * choice2  + (1+condition|subject), data=data_combined_social2, family=Gamma(link="identity"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))

summary(social_modelRT3)
CIs3RT<-confint(social_modelRT3, method = "Wald")
CIs3RT


```

#### 2.2.5 Pre-registered hypothesis
... "hungry participants are more likely to choose in line with their idiosyncratic tendencies (i.e., egoistic individuals are more likely to choose egoistic options in a hungry compared to a satiated state and altruistic individuals are more likely to choose an altruistic option in a hungry compared to a satiated state)"
```{r}
combined_summary1 <- data_combined_social2 %>%
  group_by(subject) %>%
  summarise(mean_choice = mean(choice2),std_error_choice = sd(choice2) / sqrt(n()))

median_social<- median(combined_summary1$mean_choice)

combined_summary1$type<-0
for (i in 1: nrow(combined_summary1)){
  if (combined_summary1$mean_choice[i] <= median_social) {
    combined_summary1$type[i]<-"altruist"
  } else {
    combined_summary1$type[i]<-"egoist"
  }
}
selected_columns <- combined_summary1 %>%
  select(subject, mean_choice, std_error_choice)

data_combined_social2 <- data_combined_social2 %>%
  left_join(combined_summary1, by = "subject")

combined_summary2 <- data_combined_social2 %>%
  group_by(subject, condition) %>%
  summarise(mean_choice2 = mean(choice2),std_error_choice2 = sd(choice2) / sqrt(n()))

selected_columns <- combined_summary2 %>%
  select(subject, condition, mean_choice2, std_error_choice2)

data_combined_social2 <- data_combined_social2 %>%
  left_join(selected_columns, by = c("subject", "condition"))

```
Plot 1
```{r}
data_social_sum <- data_combined_social2 %>%
  group_by(subject, condition) %>%
  summarise(mean_choice_all = unique(mean_choice), std_error_choice_all = unique(std_error_choice),
            mean_choice = unique(mean_choice2), std_error_choice_all = unique(std_error_choice2),
            type=unique(type))
  
# Calculate mean_choice_all and std_error_choice_all for altruists and egoists
overall_means <- data_social_sum %>%
  group_by(type) %>%
  summarize(mean_choice = mean(mean_choice_all),
            std_error = mean(std_error_choice_all)) %>%
  mutate(condition = "Overall")

# Prepare the data for the other four bars
type_condition_means <- data_social_sum %>%
  group_by(type, condition) %>%
  summarize(mean_choice = mean(mean_choice),
            std_error = mean(std_error_choice_all))

# Combine the data
plot_data <- bind_rows(overall_means, type_condition_means)

# Create custom labels and colors
plot_data <- plot_data %>%
  mutate(
    custom_label = case_when(
      condition == "Overall" & type == "egoist" ~ "Egoistic Choice",
      condition == "Overall" & type == "altruist" ~ "Altruistic Choice",
      TRUE ~ paste(type, condition)
    ),
    custom_color = case_when(
      condition == "Overall" & type == "egoist" ~ "orange3",
      condition == "Overall" & type == "altruist" ~ "orange",
      condition == "sated" ~ "cornflowerblue",
      condition == "hungry" ~ "gold"
    )
  )

# Reorder factor levels for custom ordering
plot_data$custom_label <- factor(plot_data$custom_label, 
                                 levels = c("Altruistic Choice", "Egoistic Choice", 
                                            "altruist sated", "egoist sated", 
                                            "altruist hungry", "egoist hungry"))

# Create a new column for legend
plot_data$legend_label <- case_when(
  plot_data$condition == "Overall" ~ "Overall",
  plot_data$condition == "sated" ~ "Sated",
  plot_data$condition == "hungry" ~ "Hungry"
)

plot_data$custom_color <- case_when(
  plot_data$condition == "Overall" & plot_data$type == "egoist" ~ scales::alpha("orange", 0.5),
  plot_data$condition == "Overall" & plot_data$type == "altruist" ~ scales::alpha("orange", 0.8),
  plot_data$condition == "sated" & plot_data$type == "egoist" ~ scales::alpha("cornflowerblue", 0.5),
  plot_data$condition == "sated" & plot_data$type == "altruist" ~ scales::alpha("cornflowerblue", 0.8),
  plot_data$condition == "hungry" & plot_data$type == "egoist" ~ scales::alpha("gold", 0.5),
  plot_data$condition == "hungry" & plot_data$type == "altruist" ~ scales::alpha("gold", 0.8)
)

# Ensure legend_label is a factor with levels in the desired order
plot_data$legend_label <- factor(plot_data$legend_label, levels = c("Overall", "Sated", "Hungry"))

# Ensure legend_label is a factor with levels in the desired order
plot_data$legend_label <- factor(plot_data$legend_label, levels = c("Overall", "Sated", "Hungry"))

# Create the plot
ggplot(plot_data, aes(x = custom_label, y = mean_choice, fill = custom_color)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = mean_choice - std_error, 
                    ymax = mean_choice + std_error),
                width = 0.25, position = position_dodge(width = 0.9)) +
  geom_text(aes(label = round(mean_choice, 2)), 
            vjust = -2.5, position = position_dodge(0.9)) +
  scale_fill_identity(guide = "legend",
                      labels = c("Overall", "Sated", "Hungry"),
                      breaks = c(scales::alpha("orange", 0.8),
                                 scales::alpha("cornflowerblue", 0.8),
                                 scales::alpha("gold", 0.8))) +
  labs(title = "",
       x = "Type",
       y = "P(Selfish Choice)",
       fill = "Condition") +
  ylim(0, 0.8) +
  scale_x_discrete(labels = c("Altruistic Choice" = "Altruist",
                              "Egoistic Choice" = "Egoist",
                              "altruist sated" = "Altruist",
                              "egoist sated" = "Egoist",
                              "altruist hungry" = "Altruist",
                              "egoist hungry" = "Egoist")) +
  myTheme #+
  #theme(axis.text.x = element_text(angle = 0, hjust = 0.5),
        #legend.position = "right")

ggsave("socialchoice_bytype.png", plot = last_plot(), dpi = 300)
### stats necessary?? Direction seems good, but no sign diff!


```

```{r}
library(ggdist)  # for stat_halfeye
library(tidyr)

# Create the raincloud plot
ggplot(data_social_sum, 
       aes(x = type, y = mean_choice, fill = condition)) +
  # Add the cloud (violin plot)
  stat_halfeye(
    adjust = 0.5,
    width = 0.5,
    alpha=0.5,
    justification = -0.2,
    .width = 0,
    point_colour = NA, 
    position = position_dodge(width = 0.8)
  ) +
  # Add the rain (individual points)
  geom_point(
    aes(color = condition),
    position = position_jitterdodge(dodge.width = 0.8, jitter.width = 0.15),
    size = 1,
    alpha = 0.5
  ) +
  # Add boxplot
  geom_boxplot(
    adjust = 0.5,
    width = 0.1,
    outlier.shape = NA,
    alpha = 0.5, 
    position = position_dodge(width = 0.8)
  ) +
  # Customize colors
  scale_fill_manual(
    values = c(
      "sated" = "cornflowerblue",
      "hungry" = "gold"
    )
  ) +
  scale_color_manual(
    values = c(
      "sated" = "cornflowerblue",
      "hungry" = "gold"
    )
  ) +
  # Customize labels and theme
  labs(
    title = "",
    x = "Type",
    y = "P(Selfish Choice)",
    fill = "Condition",
    color = "Condition"
  ) +
  # Apply your custom theme
  myTheme 

# Save the plot
ggsave("socialchoice_raincloud.png", plot = last_plot(), dpi = 300)
```


stats
```{r}
sum_social_h<-subset(data_social_sum, condition =='hungry')
sum_social_s<-subset(data_social_sum, condition =='sated')

sum_social_ego<-subset(data_social_sum, type =='egoist')
sum_social_alt<-subset(data_social_sum, type =='altruist')

sum_social_ego_h<-subset(sum_social_h, type =='egoist')
sum_social_ego_s<-subset(sum_social_s, type =='egoist')

sum_social_alt_h<-subset(sum_social_h, type =='altruist')
sum_social_alt_s<-subset(sum_social_s, type =='altruist')

ttest<-t.test(sum_social_ego_h$mean_choice, sum_social_ego_s$mean_choice, paired = TRUE)
ttest

ttest2<-t.test(sum_social_alt_h$mean_choice, sum_social_alt_s$mean_choice, paired = TRUE)
ttest2

ttest3<-t.test(sum_social_ego_h$mean_choice, sum_social_alt_h$mean_choice, paired = FALSE)
ttest3

ttest4<-t.test(sum_social_ego_s$mean_choice, sum_social_alt_s$mean_choice, paired = FALSE)
ttest4

effect_size3 <- ttest$statistic / sqrt(ttest$parameter)
effect_size3
effect_size4 <- ttest2$statistic / sqrt(ttest2$parameter)
effect_size4

effect_size5 <- ttest3$statistic / sqrt(ttest3$parameter)
effect_size5

effect_size6 <- ttest4$statistic / sqrt(ttest4$parameter)
effect_size6
```

Plot 2
```{r}
signchange <- combined_summary2 %>%
  group_by(subject) %>%
  summarise(subtracted_choice = (mean_choice2[condition == "sated"]) - (mean_choice2[condition == "hungry"]),
            satedchoice=(mean_choice2[condition == "sated"]),
            hungrychoice=(mean_choice2[condition == "hungry"]))

correlation <- cor.test(signchange$satedchoice, signchange$hungrychoice)
scatter_plot <- ggplot(signchange, aes(x = satedchoice, y = hungrychoice)) +
  geom_point(color = "#3CC71E")+
  geom_smooth(method = "lm", se = FALSE, color = "#3CC71E") +
  geom_abline(intercept = 0, slope = 1, color = "black", linetype="dashed") +
  labs(title = "", x = "P(Selfish) Sated", y = "P(Selfish) Hungry")+ 
  myTheme
scatter_plot

ggsave("Selfishness correlation.png", plot = last_plot(), dpi = 300)
correlation

ef<-correlation$statistic/ sqrt(correlation$parameter)
ef
```


### 2.3 Discount
We predict a substantial spillover effect of hunger state on intertemporal discounting, that is, hungry sooner smaller rewards over delayed larger rewards more often compared to satiated participants. This will also be reflected in shorter response times towards sooner smaller reward options in the hungry condition.
#### 2.3.1 Preparation 
Is Random effects justified?
```{r}
data_combined_discount2 <- data_combined_discount2 %>%
  mutate(choice = ifelse(
    (time_left > time_right & response == 'left') | 
    (time_left < time_right & response == 'right'),
    "patient",
    "impulsive"
  ))

data_combined_discount2 <- data_combined_discount2 %>%
  mutate(choice2 = case_when(
    choice == "impulsive" ~ 1,
    choice == "patient" ~ 0,
    TRUE ~ NA_real_  # Handle other cases, if any
  ))

data_combined_discount2 <- data_combined_discount2 %>%
  mutate(response2 = case_when(
    response == "left" ~ 1,
    response == "right" ~ 0,
    TRUE ~ NA_real_  # Handle other cases, if any
  ))

data_combined_discount2$gender2  <- ifelse((data_combined_discount2$gender == "Weiblich"), 1, 0)

#is random effects justified?
discount_model0 <- glm(choice2~1, data=data_combined_discount2, family=binomial)
discount_model1 <- glmer(choice2~(1|subject), data=data_combined_discount2, family=binomial, control = glmerControl(optimizer = "bobyqa"))
discount_model2 <- glmer(choice2~(1+condition|subject), data=data_combined_discount2, family=binomial, , control = glmerControl(optimizer = "bobyqa"))

AIC(logLik(discount_model0))
AIC(logLik(discount_model1))
AIC(logLik(discount_model2))

# AIC of random effects model smaller, hence better
```

add rel. dwell time difference impatient - patient option
```{r}
data_combined_discount2$total_dt <- (data_combined_discount2$delayleft_time+data_combined_discount2$amountleft_time+data_combined_discount2$delayright_time+data_combined_discount2$amountright_time)
data_combined_discount2$dwelldiff_impatient_rel <- 0
for (i in 1:nrow(data_combined_discount2)){
  if((data_combined_discount2$choice2[i]==1) && (data_combined_discount2$response2[i]==1)) { # impulsive & left
    data_combined_discount2$dwelldiff_impatient_rel[i] = ((data_combined_discount2$amountleft_time[i]+data_combined_discount2$delayleft_time[i])-(data_combined_discount2$amountright_time[i]+data_combined_discount2$delayright_time[i]))/data_combined_discount2$total_dt[i]
  }else if ((data_combined_discount2$choice2[i]==1) && (data_combined_discount2$response2[i]==0)) { # impulsive & right
    data_combined_discount2$dwelldiff_impatient_rel[i] = ((data_combined_discount2$amountright_time[i]+data_combined_discount2$delayright_time[i])- (data_combined_discount2$amountleft_time[i]+data_combined_discount2$delayleft_time[i]))/data_combined_discount2$total_dt[i]
  }else if ((data_combined_discount2$choice2[i]==0) && (data_combined_discount2$response2[i]==1)) { # patient & left
    data_combined_discount2$dwelldiff_impatient_rel[i] = ((data_combined_discount2$amountright_time[i]+data_combined_discount2$delayright_time[i])-(data_combined_discount2$amountleft_time[i]+data_combined_discount2$delayleft_time[i]))/data_combined_discount2$total_dt[i]
  }else if ((data_combined_discount2$choice2[i]==0) && (data_combined_discount2$response2[i]==0)) { # patient & right
    data_combined_discount2$dwelldiff_impatient_rel[i] = ((data_combined_discount2$amountleft_time[i]+data_combined_discount2$delayleft_time[i])- (data_combined_discount2$amountright_time[i]+data_combined_discount2$delayright_time[i]))/data_combined_discount2$total_dt[i]
  }
}

data_combined_discount2$rel_dwelldiff_delay<- ((data_combined_discount2$delayleft_time+data_combined_discount2$delayright_time)-(data_combined_discount2$amountleft_time + data_combined_discount2$amountright_time))/data_combined_discount2$total_dt


data_combined_discount2 <- data_combined_discount2 %>%
  group_by(subject) %>%
  mutate(scl_dwelldiff_impatient_rel = scale(dwelldiff_impatient_rel)[,1],
         scl_rel_dwelldiff_delay = scale(rel_dwelldiff_delay)[,1]
         ) %>%
  ungroup()

```

#### 2.3.2 Choice Model
```{r}
data_combined_discount2$condition <- relevel(factor(data_combined_discount2$condition), ref = "sated")
discount_model3 <- glmer(choice2~condition + scl_dwelldiff_impatient_rel + scl_rel_dwelldiff_delay + (1+condition|subject), data=data_combined_discount2, family=binomial(link="logit"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))

summary(discount_model3)

```


```{r}
# is individual varialbilty with repect to the effect of attribute attention on choice also a problem here?

# models for each participant and condition to get slopes
slope_data2 <- data_combined_discount2 %>%
  group_by(subject, condition) %>%
  do(model = glm(choice2 ~ rel_dwelldiff_delay, data = ., family = binomial)) %>%
  mutate(slope = coef(model)[2]) 


# Order based on overall slope (across conditions)
slope_summary2 <- slope_data2 %>%
  group_by(subject) %>%
  summarize(avg_slope = mean(slope, na.rm = TRUE)) %>%
  arrange(avg_slope)  # From most negative to most positive

# Create ordered factor for subject based on calculated slopes
data_combined_discount2$subject_ordered <- factor(
  data_combined_discount2$subject,
  levels = slope_summary2$subject
)

# Plot
p_raw2 <- ggplot(data_combined_discount2,
                aes(x = (rel_dwelldiff_delay), y = choice2, color = condition)) +
  geom_smooth(method = "glm", method.args = list(family=binomial), se = TRUE,
              aes(fill = condition), alpha = 0.2, linewidth=0.7) +
  geom_point(size=0.8, alpha=0.6) +
  facet_wrap(~subject_ordered, nrow=8) +
  scale_color_manual(values = c("gold", "cornflowerblue")) +
  scale_fill_manual(values = c("gold", "cornflowerblue")) +
  labs(x = expression(bold(paste("DT", Delta, "(attribute"[paste("delay")], " - attribute"[paste("amount")], ")"))), y = "P(Impatient Choice)") +
  geom_hline(yintercept = 0.5, color = "black", linetype = "dashed", linewidth=0.5) +
  geom_vline(xintercept = 0, color = "black", linetype = "dashed", linewidth=0.5) +
  ylim(0,1) +
  theme_minimal() +
  theme(
    strip.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.spacing = unit(0.3, "lines"),
    legend.position = "bottom"
  )

p_raw2
ggsave("subject_facets_ordered_by_slope_disc.png", plot = p_raw2, width = 10, height = 12, dpi = 300)
```


```{r}
discount_model4 <- glmer(choice2~condition + scl_dwelldiff_impatient_rel + scl_rel_dwelldiff_delay + (1+condition+scl_rel_dwelldiff_delay|subject), data=data_combined_discount2, family=binomial(link="logit"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=5e5), calc.derivs = FALSE))
summary(discount_model4)
discount_model5 <- glmer(choice2~condition + scl_dwelldiff_impatient_rel +scl_rel_dwelldiff_delay + (gender2) + BMI_cent + age_cent + (PA_change) + (NA_change)+ (hs_change) + (external) + (emotional) + (restricted) + (1 + condition + scl_rel_dwelldiff_delay| subject), data=data_combined_discount2, family=binomial(link="logit"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=5e5), calc.derivs = FALSE))


summary(discount_model5)

CId4 <-confint(discount_model4, method = "Wald")
CId5<-confint(discount_model5, method = "Wald")
CId4
CId5
```


#### 2.3.3 Response Time Model
```{r}
discount_RTmodel0 <- glm(RT/1000~1, data=data_combined_discount2,family=Gamma(link="identity"))
discount_RTmodel1 <- glmer(RT/1000~(1|subject), data=data_combined_discount2,family=Gamma(link="identity"))
discount_RTmodel2 <- glmer(RT/1000~(1+condition|subject), data=data_combined_discount2,family=Gamma(link="identity"))
aic_glm <- AIC(logLik(discount_RTmodel0))
aic_glmer <- AIC(logLik(discount_RTmodel1))
aic_glmer2 <- AIC(logLik(discount_RTmodel2))
aic_glm
aic_glmer
aic_glmer2

discount_modelRT3 <- glmer(RT/1000 ~ condition * choice2  + (1+condition|subject), data=data_combined_discount2, family=Gamma(link="identity"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
summary(discount_modelRT3)
CId4RT <-confint(discount_modelRT3, method = "Wald")
CId4RT


```


### 2.4 Quantify effect of hunger 
We do not observe this so called "spill-over effect". While the mean coefficients across tasks are similar, the social and discounting task do not reach significance, due to its spread. It seems therefore that the effect of hungerstate  across choice domains strongly depends on the individual and possible other latent variables are at play. 
a) Choice
```{r}
fixed_effects_food <- broom.mixed::tidy(food_model5, effects = "fixed", conf.int = TRUE)
fixed_effects_or_food <- fixed_effects_food %>%
  mutate(
    odds_ratio = exp(estimate),
    or_conf_low = exp(conf.low),
    or_conf_high = exp(conf.high)
  )

fixed_effects_or_food$term <- dplyr::recode(fixed_effects_or_food$term,
                              "(Intercept)" = "Intercept",
                              "conditionhungry" = "condition",
                              "scl_dwelldiff_taste_rel" = "DT_option", 
                              "nutri" = "DT_attribute"
                               )

fixed_effects_social <- broom.mixed::tidy(social_model4, effects = "fixed", conf.int = TRUE)
fixed_effects_or_social <- fixed_effects_social %>%
  mutate(
    odds_ratio = exp(estimate),
    or_conf_low = exp(conf.low),
    or_conf_high = exp(conf.high)
  )

fixed_effects_or_social$term <- dplyr::recode(fixed_effects_or_social$term,
                              "(Intercept)" = "Intercept",
                              "conditionhungry" = "condition",
                              "scl_dwelldiff_rel_time" = "DT_option", 
                              "scl_rel_dwelldiff_self2" = "DT_attribute"
                               )

fixed_effects_discount <- broom.mixed::tidy(discount_model4, effects = "fixed", conf.int = TRUE)
fixed_effects_or_discount <- fixed_effects_discount %>%
  mutate(
    odds_ratio = exp(estimate),
    or_conf_low = exp(conf.low),
    or_conf_high = exp(conf.high)
  )

fixed_effects_or_discount$term <- dplyr::recode(fixed_effects_or_discount$term,
                              "(Intercept)" = "Intercept",
                              "conditionhungry" = "condition",
                              "scl_dwelldiff_impatient_rel" = "DT_option", 
                              "scl_rel_dwelldiff_delay" = "DT_attribute"
                               )


# Load required libraries
library(dplyr)
library(ggplot2)
library(patchwork)  # for combining plots

# Add task labels to each dataframe
fixed_effects_or_food$task <- "Food"

fixed_effects_or_social$task <- "Social"

fixed_effects_or_discount$task <- "Discount"

# Combine all dataframes
combined_data <- bind_rows(fixed_effects_or_food, fixed_effects_or_discount, fixed_effects_or_social)



# Define colors for each task
task_colors <- c("Food" = "magenta", "Discount" = "#00FFFF", "Social" = "orange")

create_comprehensive_coef_plot_v2 <- function(data) {
  # Create better labels for the terms (reversed order)
  data$term_label <- factor(data$term, 
                           levels = c("DT_attribute", "DT_option", "condition", "Intercept"),
                           labels = c("DT(Hot Attribute)", "DT(Hot Option)", "Condition", "Intercept"))
  
  data$task <- factor(data$task, levels = c("Social", "Discount", "Food"))
  
  ggplot(data, aes(x = estimate, y = term_label, color = task)) +
    geom_point(size = 4, position = position_dodge(width = 0.5)) +
    geom_errorbar(aes(xmin = conf.low, xmax = conf.high), 
                  width = 0.3, position = position_dodge(width = 0.5)) +
    geom_vline(xintercept = 0, linetype = "dashed", color = "gray50", alpha = 0.7) +
    scale_color_manual(values = task_colors, 
                       breaks = c("Food", "Discount", "Social")) +  # Control legend order
    labs(title = "",
         x = "Estimate (log odds)",
         y = "Choice Coefficients",
         color = "Task") +
    myTheme +
    theme(
      legend.position = "right",
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      panel.grid.major.y = element_line(color = "gray90", linetype = "dotted")
    )
}

# Create the improved version
comprehensive_plot_v2 <- create_comprehensive_coef_plot_v2(combined_data)
print(comprehensive_plot_v2)

ggsave("coeff_choice.png", comprehensive_plot_v2, width=8, height=6)
```

b) RT
```{r}
fixed_effects_foodRT <- broom.mixed::tidy(food_modelRT3, effects = "fixed", conf.int = TRUE)
fixed_effects_socialRT <- broom.mixed::tidy(social_modelRT3, effects = "fixed", conf.int = TRUE)
fixed_effects_discountRT <- broom.mixed::tidy(discount_modelRT3, effects = "fixed", conf.int = TRUE)

# Rename terms
rename_terms <- function(data) {
  data$term <- dplyr::recode(data$term,
                "(Intercept)" = "Intercept",
                "conditionhungry" = "Condition",
                "choice2" = "Choice", 
                "conditionhungry:choice2" = "Condition x Choice"
  )
  return(data) 
}


fixed_effects_foodRT <-rename_terms(fixed_effects_foodRT)
fixed_effects_socialRT <-rename_terms(fixed_effects_socialRT)
fixed_effects_discountRT <-rename_terms(fixed_effects_discountRT)

# Add task labels to each dataframe
fixed_effects_foodRT$task <- "Food"
fixed_effects_socialRT$task <- "Social"
fixed_effects_discountRT$task <- "Discount"

# Combine all dataframes
combined_dataRT <- bind_rows(fixed_effects_foodRT, fixed_effects_socialRT, fixed_effects_discountRT)

reate_comprehensive_coef_plot_RT <- function(data) {
  # Create better labels for the terms (reversed order)
  data$term_label <- factor(data$term, 
                           levels = c("Condition x Choice", "Choice", "Condition", "Intercept"))
  
  data$task <- factor(data$task, levels = c("Social", "Discount", "Food"))
  
  ggplot(data, aes(x = estimate, y = term_label, color = task)) +
    geom_point(size = 4, position = position_dodge(width = 0.5)) +
    geom_errorbar(aes(xmin = conf.low, xmax = conf.high), 
                  width = 0.3, position = position_dodge(width = 0.5)) +
    geom_vline(xintercept = 0, linetype = "dashed", color = "gray50", alpha = 0.7) +
    scale_color_manual(values = task_colors, 
                       breaks = c("Food", "Discount", "Social")) +  # Control legend order
    labs(title = "",
         x = "Estimate",
         y = "RT Coefficients",
         color = "Task") +
    myTheme +
    theme(
      legend.position = "right",
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      panel.grid.major.y = element_line(color = "gray90", linetype = "dotted")
    )
}

# Create the improved version
comprehensive_plot_RT <- reate_comprehensive_coef_plot_RT(combined_dataRT)
print(comprehensive_plot_RT)

ggsave("coeff_RT.png", comprehensive_plot_RT, width=8, height=6)
```




### 2.5 correlate effect of hunger between tasks
2) Correlate the effects on a subject level, idea People who are stronger affected in food domain may also be more affected in a different domain?
 --> People who change their food choices more strongly under hunger, also seem to change their discounting decisions, while there is no relation to social choices.
```{r}
# Extract the random slope for `condition`
random_effects_food <- ranef(food_model5)$subject
random_effects_social <- ranef(social_model4)$subject
random_effects_discount <- ranef(discount_model4)$subject

random_condition_food <- (ranef(food_model5)$subject[,"conditionhungry"])
random_condition_social<- (ranef(social_model4)$subject[,"conditionhungry"])
random_condition_discount <- (ranef(discount_model4)$subject[,"conditionhungry"])+fixef(discount_model3)["conditionhungry"]

subject_specific_df <- data.frame(
  subject = rownames(random_effects_food),
  condition_effect = random_condition_food
)

subject_specific_ds <- data.frame(
  subject = rownames(random_effects_social),
  condition_effect = random_condition_social
)

subject_specific_dd <- data.frame(
  subject = rownames(random_effects_discount),
  condition_effect = random_condition_discount
)

# Add task labels to each dataframe
subject_specific_df$task <- "Food"
subject_specific_ds$task <- "Social"
subject_specific_dd$task <- "Discount"

# Combine all dataframes
combined_data2 <- bind_rows(subject_specific_df, subject_specific_dd, subject_specific_ds)

# Transform the data frame into a wide format
library(tidyr)
wide_df <- combined_data2 %>%
  select(subject, task, condition_effect) %>%
  pivot_wider(names_from = task, values_from = condition_effect, names_prefix = "effect_")

wide_df <- na.omit(wide_df)

scatter_plot <- ggplot(wide_df, aes(x = effect_Food, y = effect_Social)) +
  geom_point(color = "#FF52AC")+
  geom_smooth(method = "lm", se = FALSE, color = "#FF52AC") +
  geom_abline(intercept = 0, slope = 1, color = "black", linetype="dashed") +
  labs(title = "", x = "Effect Food", y = "Effect Social")+ 
  xlim(min(wide_df$effect_Social), max(wide_df$effect_Social))+
  ylim(min(wide_df$effect_Social), max(wide_df$effect_Social))+
  myTheme
scatter_plot

scatter_plot2 <- ggplot(wide_df, aes(x = effect_Food, y = effect_Discount)) +
  geom_point(color = "#7F7FFF")+
  geom_smooth(method = "lm", se = FALSE, color = "#7F7FFF") +
  geom_abline(intercept = 0, slope = 1, color = "black", linetype="dashed") +
  labs(title = "", x = "Effect Food", y = "Effect Discount")+ 
  xlim(min(wide_df$effect_Discount), max(wide_df$effect_Discount))+
  ylim(min(wide_df$effect_Discount), max(wide_df$effect_Discount))+
  myTheme

scatter_plot2

correlation <- cor.test(wide_df$effect_Food, wide_df$effect_Social)
correlation2 <- cor.test(wide_df$effect_Food, wide_df$effect_Discount)
correlation
correlation2

ggsave("food_social_corr.png", scatter_plot, width = 8, height = 6)
ggsave("food_discount_corr.png.png", scatter_plot2, width = 8, height = 6)

effect_size5 <- correlation$statistic / sqrt(correlation$parameter)
effect_size6 <- correlation2$statistic / sqrt(correlation2$parameter)
effect_size5 
effect_size6
```


##### Save data "had_data_2.RData" important for "D_Eyetracking.Rmd" analysis
to save DT variables important for both GLMMs and eyetracking analyses
```{r}
save(data_combined2, data_combined_social2, data_combined_discount2, file="had_data_2.RData")
```



