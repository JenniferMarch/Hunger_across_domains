---
title: "Eye-Track"
output: html_document
date: "2024-10-09"
---

## Info 
Eye-tracking for social and discounting; the one for food can be found here: https://github.com/JenniferMarch/HungryLens/blob/main/Behaviour/D_Eyetracking.Rmd

## 1 Preperations
### 1.1 Load Libraries
```{r}
#clear working environment
rm(list=ls())

#clear all plots
if(!is.null(dev.list())) dev.off()
```

### 1.2 Chreate Theme for figures
```{r}
library(ggplot2)
myTheme <- theme(
  axis.line = element_line(colour = "black"), 
  panel.grid.major = element_blank(), 
  panel.grid.minor = element_blank(),  
  panel.border = element_blank(),   
  panel.background = element_blank(),
  text=element_text(size=16, colour = "black"), 
  axis.title.x = element_text(size=20, face="bold", colour = "black"), 
  axis.title.y = element_text( size=20, face="bold", colour = "black"),
  axis.text = element_text(size=16),
  strip.text =  element_text( size=16),
  strip.background = element_rect(fill = "white", colour = "black"),
  legend.background = element_rect(colour = "black"),
  legend.key = element_blank(),
  legend.key.size = unit(3, "lines"))
```

### 1.3 Load Pre-processed Data
```{r}
load('had_data.RData')
load("social_modeling_data.RData")
load("discount_modeling_data.RData")
```


## 2 Social
### 2.1 choose selfish given dwell time option
```{r}
library(dplyr)
data_social_combined<-data_social_combined %>% 
  dplyr::mutate(response2=dplyr::recode(response, 'left'=1, 'right'=0))

# #recode ngo/value 
data_social_combined$dwelldiff_time <- 0
for (i in 1:nrow(data_social_combined)){
  if((data_social_combined$choice2[i]==1) && (data_social_combined$response2[i]==1)) { # ngo & left
    data_social_combined$dwelldiff_time[i] = (data_social_combined$ngoleft_time[i]+data_social_combined$selfleft_time[i])-(data_social_combined$ngoright_time[i]+data_social_combined$selfright_time[i])
  }else if ((data_social_combined$choice2[i]==1) && (data_social_combined$response2[i]==0)) { # ngo & right
    data_social_combined$dwelldiff_time[i] = (data_social_combined$ngoright_time[i]+data_social_combined$selfright_time[i])-(data_social_combined$ngoleft_time[i]+data_social_combined$selfleft_time[i])
  }else if ((data_social_combined$choice2[i]==0) && (data_social_combined$response2[i]==1)) { # self & left
    data_social_combined$dwelldiff_time[i] = (data_social_combined$ngoright_time[i]+data_social_combined$selfright_time[i])-(data_social_combined$ngoleft_time[i]+data_social_combined$selfleft_time[i])
  }else if ((data_social_combined$choice2[i]==0) && (data_social_combined$response2[i]==0)) { # self & right
    data_social_combined$dwelldiff_time[i] = (data_social_combined$ngoleft_time[i]+data_social_combined$selfleft_time[i])-(data_social_combined$ngoright_time[i]+data_social_combined$selfright_time[i])
  }
} 

# Define the bin edges
bin_edges <- c(-Inf, -700, -500, -300, -100, 100, 300, 500, 700, Inf)

data_social_combined$bin2 <- cut(data_social_combined$dwelldiff_time, breaks = bin_edges,
                                labels = c("<-700", "-600", "-400", "-200", "0", "200", "400", "600", 
                                            ">700"),
                                include.lowest = TRUE, right = FALSE)

```

```{r}
# Calculate the mean probability and standard error for each bin
summary_ngo <- data_social_combined %>%
  mutate(bin2 = cut(dwelldiff_time, breaks = bin_edges, labels = c("<-700", "-600", "-400", "-200", "0", "200", "400", "600", ">700"), include.lowest = TRUE)) %>%
  group_by(bin2, condition) %>%
  summarise(mean_prob_ngo = mean(choice2),
            std_error_ngo = sd(choice2) / sqrt(n()))


p1 <- ggplot(summary_ngo, aes(x = bin2, y = mean_prob_ngo, color = condition, group = condition)) +
  geom_smooth(aes(y = mean_prob_ngo, fill = condition), method = "loess", span = 0.75, se = TRUE, linetype = "solid", alpha=0.3) +
  scale_color_manual(values = c("gold", "cornflowerblue")) +
  scale_fill_manual(values = c("gold", "cornflowerblue")) +  # Set fill colors for each condition
  labs(x = "Dwell Time Difference", y = "P(Selfish Choice)") +
  geom_hline(yintercept = 0.5, color = "black", linetype = "dashed") +
  geom_vline(xintercept = "0", color = "black", linetype = "dashed") +  
  ylim(0,1)+
  myTheme
ggsave("pchoice_dwelltime_social.png",  width = 8, height = 6, plot = last_plot(), dpi = 300)
p1
```

### 2.1 choose selfish given dwell time self
```{r}
# #recode ngo/value 
data_social_combined$dwelldiff_time_self <- data_social_combined$selfleft_time+data_social_combined$selfright_time - data_social_combined$ngoleft_time+data_social_combined$ngoright_time

```

```{r}
# Calculate the mean probability and standard error for each bin
summary_self <- data_social_combined %>%
  mutate(bin2 = cut(dwelldiff_time_self, breaks = bin_edges, labels = c("<-700", "-600", "-400", "-200", "0", "200", "400", "600", ">700"), include.lowest = TRUE)) %>%
  group_by(bin2, condition) %>%
  summarise(mean_prob_ngo = mean(choice2),
            std_error_ngo = sd(choice2) / sqrt(n()))


p2 <- ggplot(summary_self, aes(x = bin2, y = mean_prob_ngo, color = condition, group = condition)) +
  geom_smooth(aes(y = mean_prob_ngo, fill = condition), method = "loess", span = 0.75, se = TRUE, linetype = "solid", alpha=0.3) +
  scale_color_manual(values = c("gold", "cornflowerblue")) +
  scale_fill_manual(values = c("gold", "cornflowerblue")) +  # Set fill colors for each condition
  labs(x = "Dwell Time Difference Self vs NGO", y = "P(Selfish Choice)") +
  geom_hline(yintercept = 0.5, color = "black", linetype = "dashed") +
  geom_vline(xintercept = "0", color = "black", linetype = "dashed") +  
  ylim(0,1)+
  myTheme
ggsave("pchoice_dwelltime_socialvsngo.png",  width = 8, height = 6, plot = last_plot(), dpi = 300)
p2
```


### 2.2 Plot more attention to ngo attribute under hunger?
```{r}
data_social_combined$att_ngo<-0
for (n in 1:nrow(data_social_combined)) {
  data_social_combined$att_self[n] <- (data_social_combined$selfleft_time[n] + data_social_combined$selfright_time[n]) /
                (sum(data_social_combined$ngoleft_time[n] + data_social_combined$ngoright_time[n] +
                    data_social_combined$selfleft_time[n] + data_social_combined$selfright_time[n]))
}

#delete NA trials
data_social_combined3 <- subset(data_social_combined,att_self!='NaN')

combined_summary <- data_social_combined3 %>%
  group_by(subject, condition) %>%
  summarise(mean_att_self = mean(att_self),
            std_error = sd(att_self) / sqrt(n()))

library(ggdist)

# Create a raincloud plot
raincloud_plot <- ggplot(combined_summary, aes(x = condition, y = mean_att_self, fill = condition)) +
  geom_violin(trim = FALSE, alpha = 0.8) +
  #geom_boxplot(width = 0.1, fill = "white", color = "black", outlier.shape = NA) +
  geom_point(position = position_jitter(width = 0.15), size = 1) +
  geom_hline(yintercept = 0.5, color = "black", linetype="dashed") +
  scale_fill_manual(values = c("gold", "cornflowerblue")) +
  xlab("Condition") +
  ylab("P(Dwell Time Self)") +
  #ggtitle("Mean Dwell Time Self Attribute per Condition") +
  ylim(0,1)+
  #scale_fill_manual(values = c("sated" = "cornflowerblue", "hungry" = "gold")) + 
  myTheme


# Display the raincloud plot
raincloud_plot

ggsave("dwelltime_self_cond_social.png", width = 7, height = 7, plot = last_plot(), dpi = 300)

```
stasts...
```{r}
att_self_h<-subset(combined_summary, condition =='hungry')
att_self_s<-subset(combined_summary, condition =='sated')

ttest<-t.test(att_self_h$mean_att_self, att_self_s$mean_att_self, paired=TRUE)
ttest

effect_size3 <- ttest$statistic / sqrt(ttest$parameter)
# no difference
```
```{r}
combined_summary1 <- data_social_combined3 %>%
  group_by(subject, condition) %>%
  summarise(mean_att_self = mean(dwelldiff_time_self),
            std_error = sd(dwelldiff_time_self) / sqrt(n()))


att_self_h2<-subset(combined_summary1, condition =='hungry')
att_self_s2<-subset(combined_summary1, condition =='sated')

ttest<-t.test(att_self_h2$mean_att_self, att_self_s2$mean_att_self, paired=TRUE)
ttest
```


### 2.3 Lets take a look at first and last fixations
```{r}
nsubj <- length(unique(data_combined$subject))
data_social_hungry_long_w0<-data_social_hungry_long
data_social_sated_long_w0<-data_social_hungry_long
data_social_hungry_long<-subset(data_social_hungry_long, fixElement != 0)
data_social_sated_long<-subset(data_social_sated_long, fixElement != 0)
```
#### 2.3.1 Recode for position
```{r}
#Fixated Element code
#1 = self left
#2 = self right
#3 = ngo left
#4 = ngo right

is_odd <- function(x) {
  x %% 2 == 1
}

# recoding function for position (even subjects saw self on upper side of screen and ngo on lower side, while odd subjects the other way around)
recode_fixation <- function(fixElement, subject) {
  ifelse(
    is_odd(x=subject), # For odd subjects, apply the recoding; For even subjects, keep the original fixElement
    dplyr::case_when(
      fixElement == 1 ~ 3,
      fixElement == 2 ~ 4,
      fixElement == 3 ~ 1,
      fixElement == 4 ~ 2,
      TRUE ~ fixElement
    ),
    fixElement  # Return original value for even subjects
  )
}

# Apply to dataframes, such that 
#fixElement2 code
#1 = upper left
#2 = upper right
#3 = lower left
#4 = lower right

# Apply to dataframes using subject column
data_social_hungry_long$fixElement2 <- recode_fixation(data_social_hungry_long$fixElement,data_social_hungry_long$subject)

data_social_sated_long$fixElement2 <- recode_fixation(data_social_sated_long$fixElement,data_social_sated_long$subject)

```

#### 2.3.2 Get first and last fixations for category and postion as well as hungry and sated dataframe
##### 2.3.2.1 hungry
```{r}
# Group the data by trial and subject
grouped_social_data_hungry <- data_social_hungry_long %>%
  group_by(trial, subject)

# a) First Fix
# Extract the first fixated element for each trial
first_fix_social_hungry <- grouped_social_data_hungry %>%
  slice(1) %>%
  select(trial, first_element_cat = fixElement, first_element_loc = fixElement2)

#category
first_fix_social_hungry_cat<-first_fix_social_hungry %>%
  group_by(first_element_cat) %>%
  summarise(n = n(), fix_prop = n/nrow(first_fix_social_hungry), 
            se_prop = sqrt((fix_prop * (1 - fix_prop)) / nsubj),
            condition = "hungry")
#location
first_fix_social_hungry_loc<-first_fix_social_hungry %>%
  group_by(first_element_loc) %>%
  summarise(n = n(), fix_prop = n/nrow(first_fix_social_hungry), 
            se_prop = sqrt((fix_prop * (1 - fix_prop)) / nsubj),
            condition = "hungry")

# b) Last Fix
# Extract the last fixated element for each trial
last_fix_social_hungry <- grouped_social_data_hungry %>%
  slice(n()) %>%
  select(trial, response, last_element_cat = fixElement, last_element_loc = fixElement2)

#category
last_fix_social_hungry_cat<-last_fix_social_hungry %>%
  group_by(last_element_cat) %>%
  summarise(n = n(), fix_prop = n/nrow(last_fix_social_hungry), 
            se_prop = sqrt((fix_prop * (1 - fix_prop)) / nsubj),
            condition = "hungry")
#location
last_fix_social_hungry_loc<-last_fix_social_hungry %>%
  group_by(last_element_loc) %>%
  summarise(n = n(), fix_prop = n/nrow(last_fix_social_hungry), 
            se_prop = sqrt((fix_prop * (1 - fix_prop)) / nsubj),
            condition = "hungry")

```

##### 2.3.2.2 sated
```{r}
# Group the data by trial and subject
grouped_social_data_sated <- data_social_sated_long %>%
  group_by(trial, subject)

# a) First Fix
# Extract the first fixated element for each trial
first_fix_social_sated <- grouped_social_data_sated %>%
  slice(1) %>%
  select(trial, first_element_cat = fixElement, first_element_loc = fixElement2)

#category
first_fix_social_sated_cat<-first_fix_social_sated %>%
  group_by(first_element_cat) %>%
  summarise(n = n(), fix_prop = n/nrow(first_fix_social_sated), 
            se_prop = sqrt((fix_prop * (1 - fix_prop)) / nsubj),
            condition = "sated")
#location
first_fix_social_sated_loc<-first_fix_social_sated %>%
  group_by(first_element_loc) %>%
  summarise(n = n(), fix_prop = n/nrow(first_fix_social_sated), 
            se_prop = sqrt((fix_prop * (1 - fix_prop)) / nsubj),
            condition = "sated")

# b) Last Fix
# Extract the last fixated element for each trial
last_fix_social_sated <- grouped_social_data_sated %>%
  slice(n()) %>%
  select(trial, response, last_element_cat = fixElement, last_element_loc = fixElement2)

#category
last_fix_social_sated_cat<-last_fix_social_sated %>%
  group_by(last_element_cat) %>%
  summarise(n = n(), fix_prop = n/nrow(last_fix_social_sated), 
            se_prop = sqrt((fix_prop * (1 - fix_prop)) / nsubj),
            condition = "sated")
#location
last_fix_social_sated_loc<-last_fix_social_sated %>%
  group_by(last_element_loc) %>%
  summarise(n = n(), fix_prop = n/nrow(last_fix_social_sated), 
            se_prop = sqrt((fix_prop * (1 - fix_prop)) / nsubj),
            condition = "sated")

```


#PLOT THE STUFF!!
```{r}
plot_fixation_proportions <- function(hungry_data, sated_data, fixation_type = c("first", "last"), plot_type = c("location", "category"),custom_labels = NULL) {
  
  # Input validation
  fixation_type <- match.arg(fixation_type)
  plot_type <- match.arg(plot_type)
  
    # Get the actual names from the provided lists
  hungry_names <- names(hungry_data)
  sated_names <- names(sated_data)
  
  # Select the appropriate data based on fixation type
  hungry_data_name <- hungry_names[grep(paste0(fixation_type, "_fix"), hungry_names)]
  sated_data_name <- sated_names[grep(paste0(fixation_type, "_fix"), sated_names)]
  
  # Get the data
  hungry_data_to_use <- hungry_data[[hungry_data_name]]
  sated_data_to_use <- sated_data[[sated_data_name]]
  
  # Set the group column name based on fixation type and plot type
  group_col <- if(plot_type == "location") {
    if(fixation_type == "first") "first_element_loc" else "last_element_loc"
  } else {
    if(fixation_type == "first") "first_element_cat" else "last_element_cat"
  }
  
  # Set x-axis label
  x_lab <- if(plot_type == "location") "Location" else "Category"
  
  # Combine the data
  combined_data <- rbind(hungry_data_to_use, sated_data_to_use)
  combined_data[[group_col]] <- as.factor(combined_data[[group_col]])
  
  
  # Create the plot
  plot <- ggplot(combined_data, aes(x = !!sym(group_col), y = fix_prop, fill = condition)) +
    geom_bar(stat = "identity", position = "dodge", width = 0.6) +
    geom_errorbar(aes(ymin = fix_prop - se_prop, ymax = fix_prop + se_prop),position = position_dodge(width = 0.6), width = 0.2, color = "black", alpha = 0.7) +
    geom_hline(yintercept = 0.25, color = "black",linetype = "dashed") +
    xlab(x_lab) +
    ylab("Proportion") +
    ggtitle("") +
    ylim(0, 1) +
    scale_fill_manual(values = c("sated" = "cornflowerblue", "hungry" = "gold")) +
    myTheme + 
    scale_x_discrete(labels = custom_labels)

  return(plot)
}
```

```{r}
location_labels <- c("1" ="upper left","2" ="upper right", "3" ="lower left","4" ="lower right")
category_labels <- c("1" = "self left", "2" = "self right", "3" = "NGO left", "4" = "NGO right")

p1 <- plot_fixation_proportions(hungry_data = list(first_fix_social_hungry_loc = first_fix_social_hungry_loc,last_fix_social_hungry_loc = last_fix_social_hungry_loc),
  sated_data = list(first_fix_social_sated_loc = first_fix_social_sated_loc,last_fix_social_sated_loc = last_fix_social_sated_loc),fixation_type = "first",plot_type = "location", custom_labels = location_labels
)
p1
ggsave("prop_firstfix_loc_social.png", width = 7, height = 7,plot = last_plot(), dpi = 300)

p2 <- plot_fixation_proportions(hungry_data = list(first_fix_social_hungry_loc = first_fix_social_hungry_loc,last_fix_social_hungry_loc = last_fix_social_hungry_loc),
  sated_data = list(first_fix_social_sated_loc = first_fix_social_sated_loc,last_fix_social_sated_loc = last_fix_social_sated_loc),fixation_type = "last",plot_type = "location", custom_labels = location_labels
)
p2
ggsave("prop_lastfix_loc_social.png", width = 7, height = 7,plot = last_plot(), dpi = 300)

p3 <- plot_fixation_proportions(hungry_data = list(first_fix_social_hungry_cat = first_fix_social_hungry_cat,last_fix_social_hungry_cat = last_fix_social_hungry_cat),
  sated_data = list(first_fix_social_sated_cat = first_fix_social_sated_cat,last_fix_social_sated_cat = last_fix_social_sated_cat),fixation_type = "first",plot_type = "category", custom_labels = category_labels
)
p3
ggsave("prop_firstfix_cat_social.png", width = 7, height = 7,plot = last_plot(), dpi = 300)

p4 <- plot_fixation_proportions(hungry_data = list(first_fix_social_hungry_cat = first_fix_social_hungry_cat,last_fix_social_hungry_cat = last_fix_social_hungry_cat),
  sated_data = list(first_fix_social_sated_cat = first_fix_social_sated_cat,last_fix_social_sated_cat = last_fix_social_sated_cat),fixation_type = "last",plot_type = "category", custom_labels = category_labels
)
p4
ggsave("prop_lastfix_cat_social.png", width = 7, height = 7,plot = last_plot(), dpi = 300)
```


### 2.4 Fixation  Transitions
```{r}
create_fixation_transitions <- function(data) {
  data$transition <- 'NA'
  
  for (i in 1:(nrow(data) - 1)) {
    if (((data$fixElement[i] == 1 && data$fixElement[i + 1] == 3) ||
         (data$fixElement[i] == 2 && data$fixElement[i + 1] == 4)) ||
        ((data$fixElement[i] == 3 && data$fixElement[i + 1] == 1) ||
         (data$fixElement[i] == 4 && data$fixElement[i + 1] == 2))) {
      data$transition[i] <- "within alternative"
      
    } else if (((data$fixElement[i] == 1 && data$fixElement[i + 1] == 2) ||
                (data$fixElement[i] == 3 && data$fixElement[i + 1] == 4)) ||
               ((data$fixElement[i] == 2 && data$fixElement[i + 1] == 1) ||
                (data$fixElement[i] == 4 && data$fixElement[i + 1] == 3))) {
      data$transition[i] <- "within attributes"
      
    } else if (((data$fixElement[i] == 1 && data$fixElement[i + 1] == 4) ||
                (data$fixElement[i] == 2 && data$fixElement[i + 1] == 3)) ||
               ((data$fixElement[i] == 4 && data$fixElement[i + 1] == 1) ||
                (data$fixElement[i] == 3 && data$fixElement[i + 1] == 2))) {
      data$transition[i] <- "diagonal"
      
    } else if (((data$fixElement[i] == 1 && data$fixElement[i + 1] == 1) ||
                (data$fixElement[i] == 2 && data$fixElement[i + 1] == 2) ||
                (data$fixElement[i] == 3 && data$fixElement[i + 1] == 3) ||
                (data$fixElement[i] == 4 && data$fixElement[i + 1] == 4))) {
      data$transition[i] <- "remain"
    }
  }
  
  return(data)
}


data_social_hungry_long <- create_fixation_transitions(data_social_hungry_long)
data_social_sated_long <- create_fixation_transitions(data_social_sated_long)
  
```

```{r}
## HUNGRY
# check proportion transitions
## exclude remain trials
data_trans <- subset(data_social_hungry_long, transition!='remain')
data_trans <- subset(data_trans, transition!='NA')
data_trans$condition<- 'hungry'
counts_trans <- table(data_trans$transition)
## SATED
# check proportion transitions
## exclude remain trials
data_transs <- subset(data_social_sated_long, transition!='remain')
data_transs <- subset(data_transs, transition!='NA')
counts_transs <- table(data_transs$transition)
data_transs$condition <- 'sated'

trans_h2 <- data_trans %>%
  group_by(subject, transition) %>%
  summarise(count = n()) %>%
  group_by(subject) %>%
  mutate(prop = count / sum(count),
         std_error = sqrt(prop * (1 - prop) / sum(count))) %>%
  select(subject, transition, prop, std_error)
trans_h2$condition<- 'hungry'

trans_s2 <- data_transs %>%
  group_by(subject, transition) %>%
  summarise(count = n()) %>%
  group_by(subject) %>%
  mutate(prop = count / sum(count),
         std_error = sqrt(prop * (1 - prop) / sum(count))) %>%
  select(subject, transition, prop, std_error)
trans_s2$condition<- 'sated'


trans_h2 <- subset(trans_h2, subject %in% trans_s2$subject)
trans_s2 <- subset(trans_s2, subject %in% trans_h2$subject)

trans<-rbind(trans_h2, trans_s2)

box_plot<- ggplot(data = trans, aes(x = transition, y = prop, fill = condition)) +
  geom_boxplot(position = position_dodge(width = 0.75)) +
  #geom_hline(yintercept = 0, color = "red") +
  xlab("Transition Type") +
  ylab("Proportion") +
  #ggtitle("Payne index across conditions") +
  scale_fill_manual(values = c("sated" = "cornflowerblue", "hungry" = "gold"))+
  ylim(0, 1)+
  myTheme
box_plot
ggsave("average_transitions2.png", width = 8, height = 6, plot = last_plot(), dpi = 300)

```
... Relevant stats
```{r}
# Create all combinations of subject, condition, and transitions
all_combinations <- expand.grid(
  subject = unique(trans$subject),
  condition = unique(trans$condition),
  transition = unique(trans$transition)
)

# Merge with the original dataframe to fill in missing rows
trans_filled <- merge(all_combinations, trans, by = c("subject", "condition", "transition"), all.x = TRUE)

# Replace missing values with smallest number
trans_filled[is.na(trans_filled)] <- .Machine$double.eps

# Perform statistical tests on the imputed data
# Get unique levels of transition
transition_levels <- unique(trans_filled$transition)

# Create an empty list to store results
wilcox_results <- list()

# Loop through each level of transition
for (level in transition_levels) {
  # Subset the data for the current transition level
  subset_data <- trans_filled[trans_filled$transition == level, ]
  
  # Perform Wilcoxon signed-rank test
  wilcox_result <- wilcox.test(prop ~ condition, data = subset_data)
  
  # Store the result in the list
  wilcox_results[[level]] <- wilcox_result
}

wilcox_results

# summary
library(rstatix)
trans_filled %>%
  group_by(condition, transition) %>%
  get_summary_stats(prop, type = "mean_sd")

## No differences between conditions
```
## 3 Discount
### 2.1 choose impulsive given dwell time
```{r}
data_discount_combined<-data_discount_combined %>% 
  dplyr::mutate(response2=dplyr::recode(response, 'left'=1, 'right'=0))

# #recode time/value 
data_discount_combined$dwelldiff_time <- 0
for (i in 1:nrow(data_discount_combined)){
  if((data_discount_combined$choice2[i]==1) && (data_discount_combined$response2[i]==1)) { # time & left
    data_discount_combined$dwelldiff_time[i] = (data_discount_combined$timeleft_time[i]+data_discount_combined$valueleft_time[i])-(data_discount_combined$timeright_time[i]+data_discount_combined$valueright_time[i])
  }else if ((data_discount_combined$choice2[i]==1) && (data_discount_combined$response2[i]==0)) { # time & right
    data_discount_combined$dwelldiff_time[i] = (data_discount_combined$timeright_time[i]+data_discount_combined$valueright_time[i])-(data_discount_combined$timeleft_time[i]+data_discount_combined$valueleft_time[i])
  }else if ((data_discount_combined$choice2[i]==0) && (data_discount_combined$response2[i]==1)) { # value & left
    data_discount_combined$dwelldiff_time[i] = (data_discount_combined$timeright_time[i]+data_discount_combined$valueright_time[i])-(data_discount_combined$timeleft_time[i]+data_discount_combined$valueleft_time[i])
  }else if ((data_discount_combined$choice2[i]==0) && (data_discount_combined$response2[i]==0)) { # value & right
    data_discount_combined$dwelldiff_time[i] = (data_discount_combined$timeleft_time[i]+data_discount_combined$valueleft_time[i])-(data_discount_combined$timeright_time[i]+data_discount_combined$valueright_time[i])
  }
} 

# Define the bin edges
bin_edges <- c(-Inf, -700, -500, -300, -100, 100, 300, 500, 700, Inf)

data_discount_combined$bin2 <- cut(data_discount_combined$dwelldiff_time, breaks = bin_edges,
                                labels = c("<-700", "-600", "-400", "-200", "0", "200", "400", "600", 
                                            ">700"),
                                include.lowest = TRUE, right = FALSE)

```

```{r}
# Calculate the mean probability and standard error for each bin
summary_time <- data_discount_combined %>%
  mutate(bin2 = cut(dwelldiff_time, breaks = bin_edges, labels = c("<-700", "-600", "-400", "-200", "0", "200", "400", "600", ">700"), include.lowest = TRUE)) %>%
  group_by(bin2, condition) %>%
  summarise(mean_prob_time = mean(choice2),
            std_error_time = sd(choice2) / sqrt(n()))


p1 <- ggplot(summary_time, aes(x = bin2, y = mean_prob_time, color = condition, group = condition)) +
  geom_smooth(aes(y = mean_prob_time, fill = condition), method = "loess", span = 0.75, se = TRUE, linetype = "solid", alpha=0.3) +
  scale_color_manual(values = c("gold", "cornflowerblue")) +
  scale_fill_manual(values = c("gold", "cornflowerblue")) +  # Set fill colors for each condition
  labs(x = "Dwell Time Difference", y = "P(Impatient Choice)") +
  geom_hline(yintercept = 0.5, color = "black", linetype = "dashed") +
  geom_vline(xintercept = "0", color = "black", linetype = "dashed") +  
  ylim(0,1)+
  myTheme
ggsave("pchoice_dwelltime_discount.png",  width = 8, height = 6, plot = last_plot(), dpi = 300)
p1
```

```{r}
# #recode ngo/value 
data_discount_combined$dwelldiff_time_time <- data_discount_combined$timeleft_time+data_discount_combined$timeright_time - data_discount_combined$valueleft_time+data_discount_combined$valueright_time 

data_discount_combined$dwelldiff_time_amount <- data_discount_combined$valueleft_time+data_discount_combined$valueright_time -data_discount_combined$timeleft_time+data_discount_combined$timeright_time 

# To get both in one summary:
data_discount_combined %>%
  group_by(condition) %>%
  summarize(
    # Time differences
    mean_time = mean(dwelldiff_time_time),
    max_time = max(dwelldiff_time_time),
    min_time = min(dwelldiff_time_time),
    # Amount differences
    mean_amount = mean(dwelldiff_time_amount),
    max_amount = max(dwelldiff_time_amount),
    min_amount = min(dwelldiff_time_amount)
  )

#THINK ABOUT BINNING!
```

```{r}
# Calculate the mean probability and standard error for each bin
summary_amount <- data_discount_combined %>%
  mutate(bin2 = cut(dwelldiff_time_time, breaks = bin_edges, labels = c("<-700", "-600", "-400", "-200", "0", "200", "400", "600", ">700"), include.lowest = TRUE)) %>%
  group_by(bin2, condition) %>%
  summarise(mean_prob_time = mean(choice2),
            std_error_time = sd(choice2) / sqrt(n()))


p2 <- ggplot(summary_amount, aes(x = bin2, y = mean_prob_time, color = condition, group = condition)) +
  geom_smooth(aes(y = mean_prob_time, fill = condition), method = "loess", span = 0.75, se = TRUE, linetype = "solid", alpha=0.3) +
  scale_color_manual(values = c("gold", "cornflowerblue")) +
  scale_fill_manual(values = c("gold", "cornflowerblue")) +  # Set fill colors for each condition
  labs(x = "Dwell Time Difference Time vs Amount", y = "P(Impatient Choice)") +
  geom_hline(yintercept = 0.5, color = "black", linetype = "dashed") +
  geom_vline(xintercept = "0", color = "black", linetype = "dashed") +  
  ylim(0,1)+
  myTheme
ggsave("pchoice_dwelltime_amountvstime.png",  width = 8, height = 6, plot = last_plot(), dpi = 300)
p2
```



### 2.2 Plot more attention to time attribute under hunger?
```{r}
data_discount_combined$att_time<-0
for (n in 1:nrow(data_discount_combined)) {
  data_discount_combined$att_value[n] <- (data_discount_combined$valueleft_time[n] + data_discount_combined$valueright_time[n]) /
                (sum(data_discount_combined$timeleft_time[n] + data_discount_combined$timeright_time[n] +
                    data_discount_combined$valueleft_time[n] + data_discount_combined$valueright_time[n]))
}

#delete NA trials
data_discount_combined3 <- subset(data_discount_combined,att_value!='NaN')

combined_summary <- data_discount_combined3 %>%
  group_by(subject, condition) %>%
  summarise(mean_att_value = mean(att_value),
            std_error = sd(att_value) / sqrt(n()))

library(ggdist)

# Create a raincloud plot
raincloud_plot <- ggplot(combined_summary, aes(x = condition, y = mean_att_value, fill = condition)) +
  geom_violin(trim = FALSE, alpha = 0.8) +
  #geom_boxplot(width = 0.1, fill = "white", color = "black", outlier.shape = NA) +
  geom_point(position = position_jitter(width = 0.15), size = 1) +
  geom_hline(yintercept = 0.5, color = "black", linetype="dashed") +
  scale_fill_manual(values = c("gold", "cornflowerblue")) +
  xlab("Condition") +
  ylab("P(Dwell Time Amount)") +
  #ggtitle("Mean Dwell Time Self Attribute per Condition") +
  ylim(0,1)+
  #scale_fill_manual(values = c("sated" = "cornflowerblue", "hungry" = "gold")) + 
  myTheme


# Display the raincloud plot
raincloud_plot

ggsave("dwelltime_self_cond_discount.png", width = 7, height = 7, plot = last_plot(), dpi = 300)

```
stats...
```{r}
#diff between conditions
att_value_h<-subset(combined_summary, condition =='hungry')
att_value_s<-subset(combined_summary, condition =='sated')

ttest<-t.test(att_value_h$mean_att_value, att_value_s$mean_att_value, paired=TRUE)
ttest

effect_size3 <- ttest$statistic / sqrt(ttest$parameter)

#different that .5?
ttest_h <- t.test(att_value_h$mean_att_value, mu = 0.5)
ttest_h

# Conduct a one-sample t-test for the second condition (att_value_s)
ttest_s <- t.test(att_value_s$mean_att_value, mu = 0.5)
ttest_s
# no difference between conditions, but participants spent significantly more time on the time attribute in both conditions!
```

### 3.3 Lets take a look at first and last fixations
Function to categorise where (location and content participants looked when)
```{r}
data_discount_hungry_long_w0<-data_discount_hungry_long
data_discount_sated_long_w0<-data_discount_hungry_long
data_discount_hungry_long<-subset(data_discount_hungry_long, fixElement != 0)
data_discount_sated_long<-subset(data_discount_sated_long, fixElement != 0)
```
#### 2.3.1 Recode for position
```{r}
#Fixated Element code
#1 = time left
#2 = time right
#3 = amount left
#4 = amount right

is_even <- function(x) {
  x %% 2 == 0
}

# recoding function for position (even subjects saw value on upper side of screen and time on lower side, while odd subjects the other way around)
recode_fixation2 <- function(fixElement, subject) {
  ifelse(
    is_even(subject),
    dplyr::case_when(
      fixElement == 1 ~ 3,
      fixElement == 2 ~ 4,
      fixElement == 3 ~ 1,
      fixElement == 4 ~ 2,
      TRUE ~ fixElement
    ),
    fixElement  # Return original value for even subjects
  )
}

# Apply to dataframes, such that 
#fixElement2 code
#1 = upper left
#2 = upper right
#3 = lower left
#4 = lower right
data_discount_hungry_long$fixElement2 <- recode_fixation2(data_discount_hungry_long$fixElement, data_discount_hungry_long$subject)
data_discount_sated_long$fixElement2 <- recode_fixation2(data_discount_sated_long$fixElement, data_discount_sated_long$subject)

```

#### 2.3.2 Get first and last fixations for category and postion as well as hungry and sated dataframe

##### 2.3.2.1 hungry
```{r}
# Group the data by trial and subject
grouped_discount_data_hungry <- data_discount_hungry_long %>%
  group_by(trial, subject)

# a) First Fix
# Extract the first fixated element for each trial
first_fix_discount_hungry <- grouped_discount_data_hungry %>%
  slice(1) %>%
  select(trial, first_element_cat = fixElement, first_element_loc = fixElement2)

#category
first_fix_discount_hungry_cat<-first_fix_discount_hungry %>%
  group_by(first_element_cat) %>%
  summarise(n = n(), fix_prop = n/nrow(first_fix_discount_hungry), 
            se_prop = sqrt((fix_prop * (1 - fix_prop)) / nsubj),
            condition = "hungry")
#location
first_fix_discount_hungry_loc<-first_fix_discount_hungry %>%
  group_by(first_element_loc) %>%
  summarise(n = n(), fix_prop = n/nrow(first_fix_discount_hungry), 
            se_prop = sqrt((fix_prop * (1 - fix_prop)) / nsubj),
            condition = "hungry")

# b) Last Fix
# Extract the last fixated element for each trial
last_fix_discount_hungry <- grouped_discount_data_hungry %>%
  slice(n()) %>%
  select(trial, response, last_element_cat = fixElement, last_element_loc = fixElement2)

#category
last_fix_discount_hungry_cat<-last_fix_discount_hungry %>%
  group_by(last_element_cat) %>%
  summarise(n = n(), fix_prop = n/nrow(last_fix_discount_hungry), 
            se_prop = sqrt((fix_prop * (1 - fix_prop)) / nsubj),
            condition = "hungry")
#location
last_fix_discount_hungry_loc<-last_fix_discount_hungry %>%
  group_by(last_element_loc) %>%
  summarise(n = n(), fix_prop = n/nrow(last_fix_discount_hungry), 
            se_prop = sqrt((fix_prop * (1 - fix_prop)) / nsubj),
            condition = "hungry")

```

##### 2.3.2.2 sated
```{r}
# Group the data by trial and subject
grouped_discount_data_sated <- data_discount_sated_long %>%
  group_by(trial, subject)

# a) First Fix
# Extract the first fixated element for each trial
first_fix_discount_sated <- grouped_discount_data_sated %>%
  slice(1) %>%
  select(trial, first_element_cat = fixElement, first_element_loc = fixElement2)

#category
first_fix_discount_sated_cat<-first_fix_discount_sated %>%
  group_by(first_element_cat) %>%
  summarise(n = n(), fix_prop = n/nrow(first_fix_discount_sated), 
            se_prop = sqrt((fix_prop * (1 - fix_prop)) / nsubj),
            condition = "sated")
#location
first_fix_discount_sated_loc<-first_fix_discount_sated %>%
  group_by(first_element_loc) %>%
  summarise(n = n(), fix_prop = n/nrow(first_fix_discount_sated), 
            se_prop = sqrt((fix_prop * (1 - fix_prop)) / nsubj),
            condition = "sated")

# b) Last Fix
# Extract the last fixated element for each trial
last_fix_discount_sated <- grouped_discount_data_sated %>%
  slice(n()) %>%
  select(trial, response, last_element_cat = fixElement, last_element_loc = fixElement2)

#category
last_fix_discount_sated_cat<-last_fix_discount_sated %>%
  group_by(last_element_cat) %>%
  summarise(n = n(), fix_prop = n/nrow(last_fix_discount_sated), 
            se_prop = sqrt((fix_prop * (1 - fix_prop)) / nsubj),
            condition = "sated")
#location
last_fix_discount_sated_loc<-last_fix_discount_sated %>%
  group_by(last_element_loc) %>%
  summarise(n = n(), fix_prop = n/nrow(last_fix_discount_sated), 
            se_prop = sqrt((fix_prop * (1 - fix_prop)) / nsubj),
            condition = "sated")

```

```{r}
location_labels <- c("1" ="upper left","2" ="upper right", "3" ="lower left","4" ="lower right")
category_labels <- c("1" = "time left", "2" = "time right", "3" = "amount left", "4" = "amount right")

p1 <- plot_fixation_proportions(hungry_data = list(first_fix_discount_hungry_loc = first_fix_discount_hungry_loc,last_fix_discount_hungry_loc = last_fix_discount_hungry_loc),
  sated_data = list(first_fix_discount_sated_loc = first_fix_discount_sated_loc,last_fix_discount_sated_loc = last_fix_discount_sated_loc),fixation_type = "first",plot_type = "location", custom_labels = location_labels
)
p1
ggsave("prop_firstfix_loc_discount.png", width = 7, height = 7,plot = last_plot(), dpi = 300)

p2 <- plot_fixation_proportions(hungry_data = list(first_fix_discount_hungry_loc = first_fix_discount_hungry_loc,last_fix_discount_hungry_loc = last_fix_discount_hungry_loc),
  sated_data = list(first_fix_discount_sated_loc = first_fix_discount_sated_loc,last_fix_discount_sated_loc = last_fix_discount_sated_loc),fixation_type = "last",plot_type = "location", custom_labels = location_labels
)
p2
ggsave("prop_lastfix_loc_discount.png", width = 7, height = 7,plot = last_plot(), dpi = 300)

p3 <- plot_fixation_proportions(hungry_data = list(first_fix_discount_hungry_cat = first_fix_discount_hungry_cat,last_fix_discount_hungry_cat = last_fix_discount_hungry_cat),
  sated_data = list(first_fix_discount_sated_cat = first_fix_discount_sated_cat,last_fix_discount_sated_cat = last_fix_discount_sated_cat),fixation_type = "first",plot_type = "category", custom_labels = category_labels
)
p3
ggsave("prop_firstfix_cat_discount.png", width = 7, height = 7,plot = last_plot(), dpi = 300)

p4 <- plot_fixation_proportions(hungry_data = list(first_fix_discount_hungry_cat = first_fix_discount_hungry_cat,last_fix_discount_hungry_cat = last_fix_discount_hungry_cat),
  sated_data = list(first_fix_discount_sated_cat = first_fix_discount_sated_cat,last_fix_discount_sated_cat = last_fix_discount_sated_cat),fixation_type = "last",plot_type = "category", custom_labels = category_labels
)
p4
ggsave("prop_lastfix_cat_discount.png", width = 7, height = 7,plot = last_plot(), dpi = 300)
```



```{r}
data_discount_hungry_long <- create_fixation_transitions(data_discount_hungry_long)
data_discount_sated_long <- create_fixation_transitions(data_discount_sated_long)
## HUNGRY
# check proportion transitions
## exclude remain trials
data_trans <- subset(data_discount_hungry_long, transition!='remain')
data_trans <- subset(data_trans, transition!='NA')
data_trans$condition<- 'hungry'
counts_trans <- table(data_trans$transition)
## SATED
# check proportion transitions
## exclude remain trials
data_transs <- subset(data_discount_sated_long, transition!='remain')
data_transs <- subset(data_transs, transition!='NA')
counts_transs <- table(data_transs$transition)
data_transs$condition <- 'sated'

trans_h2 <- data_trans %>%
  group_by(subject, transition) %>%
  summarise(count = n()) %>%
  group_by(subject) %>%
  mutate(prop = count / sum(count),
         std_error = sqrt(prop * (1 - prop) / sum(count))) %>%
  select(subject, transition, prop, std_error)
trans_h2$condition<- 'hungry'

trans_s2 <- data_transs %>%
  group_by(subject, transition) %>%
  summarise(count = n()) %>%
  group_by(subject) %>%
  mutate(prop = count / sum(count),
         std_error = sqrt(prop * (1 - prop) / sum(count))) %>%
  select(subject, transition, prop, std_error)
trans_s2$condition<- 'sated'


trans_h2 <- subset(trans_h2, subject %in% trans_s2$subject)
trans_s2 <- subset(trans_s2, subject %in% trans_h2$subject)

trans<-rbind(trans_h2, trans_s2)

box_plot<- ggplot(data = trans, aes(x = transition, y = prop, fill = condition)) +
  geom_boxplot(position = position_dodge(width = 0.75)) +
  #geom_hline(yintercept = 0, color = "red") +
  xlab("Transition Type") +
  ylab("Proportion") +
  #ggtitle("Payne index across conditions") +
  scale_fill_manual(values = c("sated" = "cornflowerblue", "hungry" = "gold"))+
  ylim(0, 1)+
  myTheme
box_plot
ggsave("average_transitions_discount.png", width = 8, height = 6, plot = last_plot(), dpi = 300)

```
### Check overall fix props
```{r}
data_social_hungry$fixprob_selfleft <- data_social_hungry$selfleft_time/(data_social_hungry$selfleft_time + data_social_hungry$selfright_time + data_social_hungry$ngoleft_time + data_social_hungry$ngoright_time)
mean(data_social_hungry$fixprob_selfleft,na.rm = TRUE)

data_social_hungry$fixprob_selfright <- data_social_hungry$selfright_time/(data_social_hungry$selfleft_time + data_social_hungry$selfright_time + data_social_hungry$ngoleft_time + data_social_hungry$ngoright_time)
mean(data_social_hungry$fixprob_selfright,na.rm = TRUE)
```

