---
title: "Meta_modelfree"
output: html_document
date: "2024-10-23"
---
### Information
This script creates combines questionnaire and experimental data, It calculates relevant control variables for the GLMMs and implements the preprocessing in line with our preregistration: https://osf.io/tmdw3 
Ultimately, the script saves the dataframes used in behavioural and modeling analyses (in B_GLMMs.Rmd and things in Modeling folder). 

Original xlsx and csv files can provided upon request. Variables collected but not considered in our analyses include: menstrual cycle (all information to estimate cycle), estimated last meal intake (what, how much and when) as well as usual breakfast routine (how often, what and when). All other variables are contained in the .RData files.

### Variables
```{r}
# TBA
# List of variables needed for the GLMM (and cognitive modeling)
# value difference (VD) of each attribute: up_vd, down_vd
# proportion of fixation: fixProp1-4
# dwell time difference (dwelldiff) of each attribute: up_dwelldiff, down_dwelldiff
```

### 1. Preparations
```{r}
#clear working environment
rm(list=ls())

#clear all plots
if(!is.null(dev.list())) dev.off()

#load required libraries
library(readxl)
library(ggpubr)
library(rstatix)
library(readr)
library(tidyr)
library(dplyr)
library(zoo)
library (ggplot2)
library(tibble)
library(rstatix)
library(tidyverse)
library(ez) #
library(lme4)
library(lmerTest)

```

### 2. Load Data 
#### 2.1 Food, Social, Discount (sated condition only)
```{r, message=FALSE, warning=FALSE, echo=FALSE}
#clear working environment
rm(list=ls())

# List of RData file names
filelist <- c("food_modeling_data.RData","social_modeling_data.RData", "discount_modeling_data.RData")

# Loop through each RData file
for (file in filelist) {
  
  # Load the RData file
  load(paste0("../data/", file))
  
  # Get all objects in the current environment
  loaded_objects <- ls()
  
  # Find the object that matches the pattern "data_*_sated"
  sated_object_name <- grep("data_.", loaded_objects, value = TRUE)
  # Remove any objects that contain "_long"
  sated_object_name <- sated_object_name[!grepl("_long", sated_object_name)]
  sated_object_name <- sated_object_name[!grepl("_combined", sated_object_name)]
}

#initialize data
org_data_food_sated <- tibble(); org_data_food_hungry <- tibble()
org_data_social_sated <- tibble(); org_data_social_hungry <- tibble()
org_data_discount_sated <- tibble(); org_data_discount_hungry <- tibble()

# start rearrange data so that different datasets have the same variable names
for (datafile in sated_object_name) {
  rm(trial_data)
  rm(tempData)
  trial_data <- get(datafile)
  # keep useful variables
  tempData <- trial_data %>% select(subject, RT, choice) #subject, RT, response
  
  if (grepl("neu", datafile)) { 
    upleft_fix <- trial_data$foodleft_fix # food
    upright_fix <- trial_data$foodright_fix # food
    downleft_fix <- trial_data$nutrileft_fix # nutrition
    downright_fix <- trial_data$nutriright_fix # nutrition
    upleft_time <- trial_data$foodleft_time
    upright_time <- trial_data$foodright_time
    downleft_time <- trial_data$nutrileft_time
    downright_time <- trial_data$nutriright_time
    upleft_val <- trial_data$taste_left
    upright_val <- trial_data$taste_right
    downleft_val <- trial_data$health_left
    downright_val <- trial_data$health_right
  } else if (grepl("social", datafile)) { 
    upleft_fix <- trial_data$selfleft_fix # self
    upright_fix <- trial_data$selfright_fix # self
    downleft_fix <- trial_data$ngoleft_fix # ngo
    downright_fix <- trial_data$ngoright_fix # ngo
    upleft_time <- trial_data$selfleft_time
    upright_time <- trial_data$selfright_time
    downleft_time <- trial_data$ngoleft_time
    downright_time <- trial_data$ngoright_time
    upleft_val <- trial_data$self_left
    upright_val <- trial_data$self_right
    downleft_val <- trial_data$ngo_left
    downright_val <- trial_data$ngo_right
  } else if (grepl("discount", datafile)) {
    upleft_fix <- trial_data$valueleft_fix # amount
    upright_fix <- trial_data$valueright_fix # amount
    downleft_fix <- trial_data$timeleft_fix # delay
    downright_fix <- trial_data$timeright_fix # delay
    upleft_time <- trial_data$valueleft_time
    upright_time <- trial_data$valueright_time
    downleft_time <- trial_data$timeleft_time
    downright_time <- trial_data$timeright_time
    upleft_val <- trial_data$value_left
    upright_val <- trial_data$value_right
    downleft_val <- trial_data$time_left
    downright_val <- trial_data$time_right
  }
  
  # Create a new row as a data frame
  new_row <- data.frame(
    upleft_val = upleft_val, 
    upright_val = upright_val, 
    downleft_val = downleft_val, 
    downright_val = downright_val,
    response = as.numeric(trial_data$response == "left"), #1: left; 0: right
    upleft_fix = upleft_fix,
    upright_fix = upright_fix,
    downleft_fix = downleft_fix,
    downright_fix = downright_fix,
    upleft_time = upleft_time,
    upright_time = upright_time,
    downleft_time = downleft_time,
    downright_time = downright_time,
    stringsAsFactors = FALSE  # Ensure character variables are not converted to factors
  )
  trial_data <- cbind(tempData, new_row)
  
  # store the data to corresponding task/condition
  if (grepl("_neu", datafile) & grepl("sated", datafile)) {
    org_data_food_sated <- trial_data
  } else if  (grepl("_neu", datafile) & grepl("hungry", datafile)) {
    org_data_food_hungry <- trial_data
  } else if (grepl("social", datafile) & grepl("sated", datafile)) {
    org_data_social_sated <- trial_data
  } else if  (grepl("social", datafile) & grepl("hungry", datafile)) {
    org_data_social_hungry <- trial_data
  } else if  (grepl("discount", datafile) & grepl("sated", datafile)) {
    org_data_discount_sated <- trial_data
  } else if  (grepl("discount", datafile) & grepl("hungry", datafile)) {
    org_data_discount_hungry <- trial_data
  } 
  
}
```
#### 2.2 Clothing
```{r, message=FALSE, warning=FALSE, echo=FALSE}
# data from https://osf.io/d7s6c/ and https://osf.io/f2urs/
# Upleftval/ uprightval/ downleftval/downrightval: preferential ratings of the options at different positions
# ROI: currently gazed location (1: upper left 2: upper right 3: down left 4: down right). 
# NOTE: 
#   choice: left option is chosen (0 or 1)
#   coding: up: cloth's rating; down: brand's rank (20 levels)

# Load data
# data_raw_clothing <- read.csv("../data/moneyrisk.csv") 
load("../data/fromYang2022/Brand_Data_Clean.RData")

# Create empty dataframes for each category
data_clothing <- tibble()

# Read in data for all participants in all conditions
# summarize the dwell time for each attribute in each trial (so far the fixation times are stored separately within a trial)
subjlist <- seq_along(brand_present_sub)
for (subject in subjlist) {
  # Get the subject number from the file name
  subdata <- brand_present_sub[[subject]]
  Ntrial <- sum(subdata$fixnum == 1)
  # Identify indices where fixnum == 1
  indices <- which(subdata$fixnum == 1)
  
  # Create a sequence of labels (1, 2, 3, etc.) of the same length as identified indices
  labels <- seq_along(indices)
  
  # Assign these labels to a new column 'fixation_label'
  subdata$trial <- NA  # Create a new column initialized with NA
  subdata$trial[indices] <- labels  # Assign labels to the identified rows
  
  for (t in 1:Ntrial) {
    if (t<Ntrial) {
      trial_start <- which(subdata$trial == t)
      trial_end <- which(subdata$trial == (t+1))-1
    } else {
      trial_start <- which(subdata$trial == t)
      trial_end <- nrow(subdata)
    }
    trial_data <- subdata[trial_start:trial_end, ]
    Nfix <-  unique(trial_data$fixnum)
    
    #list of variables
    # note: ROI: currently gazed location (1: upper left 2: upper right 3: down left 4: down right). 
    upleft_fix <- sum(trial_data$roi == 1) # cloth's rating
    upright_fix <- sum(trial_data$roi == 2)  # cloth's rating
    downleft_fix <- sum(trial_data$roi == 3) # brand's rank
    downright_fix <- sum(trial_data$roi == 4) # brand's rank 
    upleft_time <- sum(trial_data$fixdur[trial_data$roi == 1])
    upright_time <- sum(trial_data$fixdur[trial_data$roi == 2])
    downleft_time <- sum(trial_data$fixdur[trial_data$roi == 3])
    downright_time <- sum(trial_data$fixdur[trial_data$roi == 4])
    upleft_val <- trial_data$upleftval[1]
    upright_val <- trial_data$uprightval[1]
    downleft_val <- trial_data$downleftval[1]
    downright_val <- trial_data$downrightval[1]
    
    
    # Create a new row as a data frame
    new_row <- data.frame(
      subject = subject,
      trial = t,
      upleft_val = upleft_val, # cloth's rating
      upright_val = upright_val, # cloth's rating
      downleft_val = downleft_val, # brand's rank
      downright_val = downright_val, # brand's rank
      response = trial_data$choice[1], #1: left; 0: right
      RT =  trial_data$rt[1],
      upleft_fix = upleft_fix,
      upright_fix = upright_fix,
      downleft_fix = downleft_fix,
      downright_fix = downright_fix,
      upleft_time = upleft_time,
      upright_time = upright_time,
      downleft_time = downleft_time,
      downright_time = downright_time,
      stringsAsFactors = FALSE  # Ensure character variables are not converted to factors
    )
    data_clothing <- rbind(data_clothing, new_row)
  }
}
```

### 3. Add additional info to  dataframes
Include:
- Value differences
- dwell time difference
- zscored dwell difference for each subjects
- proportion of dwell time

```{r}
add_variables <- function(data){
  # inclusion criteria
  validT <- data$RT > 0 & is.na(data$RT) == 0
  data <- data[validT, ]
  
  # vd of each attribute (left vs. right)
  data$up_vd <- data$upleft_val - data$upright_val
  data$down_vd <- data$downleft_val - data$downright_val
  
  # dwell difference (left vs. right)
  data$up_dwelldiff <- data$upleft_time - data$upright_time
  data$down_dwelldiff <- data$downleft_time - data$downright_time
  
  # proportion of dwell time
  allfixtime <- data$upleft_time + data$upright_time + data$downleft_time + data$downright_time
  data$fixProp1 <- data$upleft_time/allfixtime
  data$fixProp2 <- data$upright_time/allfixtime
  data$fixProp3 <- data$downleft_time/allfixtime
  data$fixProp4 <- data$downright_time/allfixtime
  data$up_fixpropdiff <- data$fixProp1 - data$fixProp2 #(left vs. right)
  data$down_fixpropdiff <- data$fixProp3 - data$fixProp4 #(left vs. right)
  
  
  # Initialize z_data
  z_data <- tibble()
  
  # Get unique subjects
  subjlist <- unique(data$subject)
  for (s in subjlist){
    # Create a subset for the current subject
    subjdata <- data[data$subject == s, ]
    
    # Calculate z-scores for each variable
    subjdata$z_up_vd <- scale(subjdata$up_vd)
    subjdata$z_down_vd <- scale(subjdata$down_vd)
    subjdata$z_up_dwelldiff <- scale(subjdata$up_dwelldiff)
    subjdata$z_down_dwelldiff <- scale(subjdata$down_dwelldiff)
    subjdata$z_up_fixpropdiff <- scale(subjdata$up_fixpropdiff)
    subjdata$z_down_fixpropdiff <- scale(subjdata$down_fixpropdiff)
    z_data <- rbind(z_data, subjdata)
  }
  return(z_data)
}

# List of dataset names
dataset_names <- c("org_data_food_sated", "org_data_food_hungry", "org_data_social_sated", "org_data_social_hungry", "org_data_discount_sated", "org_data_discount_hungry", "data_clothing")

# Loop through the datasets and apply the add_variables function
for (name in dataset_names) {
  assign(name, add_variables(get(name)))
}

# Save the modified datasets
save(org_data_food_sated, org_data_food_hungry, org_data_social_sated, org_data_social_hungry, org_data_discount_sated, org_data_discount_hungry, data_clothing, file = "../data/datasets.RData")
```

### 4 desciptive results
[add descriptions]
```{r}
# clean the environment and load the organized data again
rm(list=ls())
load("../data/datasets.RData")

# group means based on subject, choice, fixation time (upper attribute), fixation time (lower attribute)
calculate_mean <- function(data){
  results <- data %>%
    group_by(subject) %>%
    summarise(
      mean_rt = mean(RT, na.rm = TRUE),       # Mean of 'rt'
      mean_choice = mean(response, na.rm = TRUE),  # Mean of 'choice'
      mean_dwellup = mean(fixProp1+fixProp2, na.rm = TRUE),
      mean_dwelldown = mean(fixProp3+fixProp4, na.rm = TRUE),
      mean_upfixPropdiff = mean(up_fixpropdiff, na.rm = TRUE),  # Mean of 'choice'
      mean_downfixPropdiff = mean(down_fixpropdiff, na.rm = TRUE),       # Mean of 'rt'
      #mean_choice = mean(choice, na.rm = TRUE)  # Mean of 'choice'
    )
  return(results)
}

# Create a list of your datasets
datasets <- list(data_clothing = data_clothing, 
                 data_food_sated = org_data_food_sated,
                 data_food_hungry = org_data_food_hungry,
                 data_social_sated = org_data_social_sated,
                 data_social_hungry = org_data_social_hungry, 
                 data_discount_sated = org_data_discount_sated,
                 data_discount_hungry = org_data_discount_hungry)

# Initialize an empty list to store the results
mean_data_list <- list()

# Loop through each dataset in the list
count <- 0
mean_of_mean <- matrix(data = NA, nrow = length(names(datasets)), ncol = 7)
for (name in names(datasets)) {
  count <- count +1
  # Compute the mean for the current dataset
  mean_data_list[[name]] <- calculate_mean(datasets[[name]])
  subdata <- mean_data_list[[name]] 
  mean_of_mean[count, 1] <- name  # Store the dataset name
  mean_of_mean[count, 2] <- mean(subdata$mean_rt)
  mean_of_mean[count, 3] <- mean(subdata$mean_choice)
  mean_of_mean[count, 4] <- mean(subdata$mean_dwellup)
  mean_of_mean[count, 5] <- mean(subdata$mean_dwelldown)
  mean_of_mean[count, 6] <- mean(subdata$mean_upfixPropdiff)
  mean_of_mean[count, 7] <- mean(subdata$mean_downfixPropdiff)
}
```

### 5 GLM
[add descriptions]
```{r}
rm(data_interested)
data_interested <- list("data_clothing", "org_data_food_sated", "org_data_food_hungry", "org_data_social_sated", "org_data_social_hungry","org_data_discount_sated", "org_data_discount_hungry")

# Define the models as a list of formulas
model_formulas <- list(
  model1 = response ~ z_up_vd + z_down_vd + (1 | subject),
  model2 = response ~ z_up_vd + z_down_vd + z_up_fixpropdiff + (1 | subject),
  model3 = response ~ z_up_vd + z_down_vd + z_down_fixpropdiff + (1 | subject),
  model4 = response ~ z_up_vd + z_down_vd + z_up_fixpropdiff + z_down_fixpropdiff + (1 | subject)
)

# Initialize a list to store all glm results by dataset and model type
glm_results <- list()

# Initialize an empty list to store AIC results
aic_results <- data.frame(dataset = character(), model = character(), aic = numeric(), stringsAsFactors = FALSE)

# Setting global options to mute specific warnings
options(lme4.warnOnlyOnce = FALSE)   # Muting warning repeats

# Loop through each dataset
for (data_name in data_interested) {
  # Retrieve the dataset using `get`
  dataset <- get(data_name)
  dataset <- dataset[dataset$up_dwelldiff >0 | dataset$down_dwelldiff >0, ]
  
  # Initialize a sublist for the current dataset
  glm_results[[data_name]] <- list()
  
  # Loop through each model formula
  for (model_name in names(model_formulas)) {
    formula <- model_formulas[[model_name]]
    
    # Run the GLM model and store the result
    glm_results[[data_name]][[model_name]] <- glmer(
      formula,
      data = dataset,
      family = binomial(link = "logit"),
      control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 5e5))
    )
    
    # Extract the AIC value
    aic_value <- AIC(glm_results[[data_name]][[model_name]])
    
    # Append the AIC value to the results data frame
    aic_results <- rbind(aic_results, data.frame(dataset = data_name, model = model_name, aic = aic_value))
  }
}
  
# aic_results suggest that model4 is the best model to explain choice for all datasets!
```


### 6 attribute weight and dwell-time allocation
```{r}
# List of datasets of interest
data_interested <- list("data_clothing", "org_data_food_sated", "org_data_social_sated","org_data_discount_sated")
# Initialize an empty data frame to store coefficient summaries
coef_summary <- data.frame(dataset = character(), term = character(), estimate = numeric(), std_error = numeric(), z_value = numeric(), p_value = numeric(), stringsAsFactors = FALSE)

# Loop through each dataset in data_interested
for (data_name in data_interested) {
  # Check if model4 exists in the glm_results for the dataset
  if ("model4" %in% names(glm_results[[data_name]])) {
    model <- glm_results[[data_name]][["model4"]]
    
    # Extract the summary of model4
    model_summary <- summary(model)
    
    # Get coefficient estimates and standard errors
    coef_data <- data.frame(
      dataset = data_name,
      term = rownames(model_summary$coefficients),
      estimate = model_summary$coefficients[, "Estimate"],
      std_error = model_summary$coefficients[, "Std. Error"],
      z_value = model_summary$coefficients[, "z value"],
      p_value = model_summary$coefficients[, "Pr(>|z|)"]
    )
    
    # Append the coefficient data to the summary data frame
    coef_summary <- rbind(coef_summary, coef_data)
  } else {
    message(paste("Model4 not found for dataset:", data_name))
  }
}

# Print the coefficient summary
print(coef_summary)
```

```{r}
  save(data_combined, data_combined_neu, data_combined_want, data_social_combined, data_discount_combined, file="had_data.RData")
  save(data_combined, data_sated_neu, data_hungry_neu, data_hungry_long, data_sated_long, file="food_modeling_data.RData")
  save(data_social_combined, data_social_sated, data_social_hungry, data_social_hungry_long, data_social_sated_long, file="social_modeling_data.RData")
  save(data_discount_combined, data_discount_sated, data_discount_hungry, data_discount_hungry_long, data_discount_sated_long, file="discount_modeling_data.RData")
```