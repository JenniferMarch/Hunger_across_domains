---
title: "Organize data into the same format"
output: html_document
date: "2024-10-23"
---
### Information
The script used the data from Jenna (food, social, temporal discounting) and Yang et al., 2022 (clothing). Since the script relies on the data organized by other scripts (e.g., Behaviour/A_Preprocess.Rmd by Jenna), WE HAVE TO RERUN THIS SCRIPT, B_organizaedata.Rmd if any change in those files is made. 

** RERUN THIS SCRIPT if any change in Behaviour/A_Preprocess.Rmd is made. 

### Inputs and Variables
```{r}
# Inputs: 
# ../data/fromYang2022/Brand_Data_Clean.RData"
# ../data/food_modeling_data.RData
# ../data/social_modeling_data.RData
# ../data/discounting_modeling_data.RData

# Outputs:
# ../data/Clothing_data.RData
# ../data/datasets.RData (this is the one contains all datasets from the sated condition)
```

### 1. Preparations
```{r}
#clear working environment
rm(list=ls())

#clear all plots
if(!is.null(dev.list())) dev.off()

#load required libraries
LibraryList <- c("readxl", "ggpubr", "rstatix", "readr", 
                 "tidyr","dplyr","zoo", "ggplot2", "tibble",
                 "tidyverse","ez","lme4", "lmerTest")
invisible(lapply(LibraryList, library, character.only = TRUE))
```

### 2. Load Data 
#### 2.1 Food, Social, Discount (sated condition only)
```{r, message=FALSE, warning=FALSE, echo=FALSE}
# List of RData file names
filelist <- c("food_modeling_data.RData","social_modeling_data.RData", "discount_modeling_data.RData")

# Loop through each RData file
for (file in filelist) {
  
  # Load the RData file
  load(paste0("data/", file))
  
  # Get all objects in the current environment
  loaded_objects <- ls()
  
  # Find the object that matches the pattern "data_*_sated"
  sated_object_name <- grep("data_.", loaded_objects, value = TRUE)
  # Remove any objects that contain "_long"
  sated_object_name <- sated_object_name[!grepl("_long", sated_object_name)]
  sated_object_name <- sated_object_name[!grepl("_combined", sated_object_name)]
}

#initialize data
org_data_food_sated <- tibble(); org_data_food_hungry <- tibble()
org_data_social_sated <- tibble(); org_data_social_hungry <- tibble()
org_data_discount_sated <- tibble(); org_data_discount_hungry <- tibble()

# start rearranging data so that different datasets have the same variable names
for (datafile in sated_object_name) {
  rm(trial_data)
  rm(tempData)
  trial_data <- get(datafile)
  # keep useful variables
  tempData <- trial_data %>% select(subject, RT, choice) #subject, RT, response
  
  if (grepl("neu", datafile)) { 
    upleft_fix <- trial_data$foodleft_fix # food
    upright_fix <- trial_data$foodright_fix # food
    downleft_fix <- trial_data$nutrileft_fix # nutrition
    downright_fix <- trial_data$nutriright_fix # nutrition
    upleft_time <- trial_data$foodleft_time
    upright_time <- trial_data$foodright_time
    downleft_time <- trial_data$nutrileft_time
    downright_time <- trial_data$nutriright_time
    upleft_val <- trial_data$taste_left
    upright_val <- trial_data$taste_right
    downleft_val <- trial_data$health_left
    downright_val <- trial_data$health_right
  } else if (grepl("social", datafile)) { 
    upleft_fix <- trial_data$selfleft_fix # self
    upright_fix <- trial_data$selfright_fix # self
    downleft_fix <- trial_data$ngoleft_fix # ngo
    downright_fix <- trial_data$ngoright_fix # ngo
    upleft_time <- trial_data$selfleft_time
    upright_time <- trial_data$selfright_time
    downleft_time <- trial_data$ngoleft_time
    downright_time <- trial_data$ngoright_time
    upleft_val <- trial_data$self_left
    upright_val <- trial_data$self_right
    downleft_val <- trial_data$ngo_left
    downright_val <- trial_data$ngo_right
  } else if (grepl("discount", datafile)) {
    upleft_fix <- trial_data$delayleft_fix # delay should be the "hot" attribute
    upright_fix <- trial_data$delayright_fix # delay
    downleft_fix <- trial_data$amountleft_fix # amount
    downright_fix <- trial_data$amountright_fix # amount
    upleft_time <- trial_data$delayleft_time
    upright_time <- trial_data$delayright_time
    downleft_time <- trial_data$amountleft_time
    downright_time <- trial_data$amountright_time
    upleft_val <- trial_data$time_left
    upright_val <- trial_data$time_right
    downleft_val <- trial_data$value_left
    downright_val <- trial_data$value_right
  }
  
  # Create a new row as a data frame
  new_row <- data.frame(
    upleft_val = upleft_val, 
    upright_val = upright_val, 
    downleft_val = downleft_val, 
    downright_val = downright_val,
    response = as.numeric(trial_data$response == "left"), #1: left; 0: right
    response_better_up = as.numeric((trial_data$response == "left" & (upleft_val>upright_val)) | (trial_data$response == "right" & (upleft_val<=upright_val))), #1: left; 0: right
    upleft_fix = upleft_fix,
    upright_fix = upright_fix,
    downleft_fix = downleft_fix,
    downright_fix = downright_fix,
    upleft_time = upleft_time, # will be reversed in Section3.2
    upright_time = upright_time, # will be reversed in Section3.2
    downleft_time = downleft_time,
    downright_time = downright_time,
    stringsAsFactors = FALSE  # Ensure character variables are not converted to factors
  )
  trial_data <- cbind(tempData, new_row)
  
  # store the data to corresponding task/condition
  if (grepl("_neu", datafile) & grepl("sated", datafile)) {
    org_data_food_sated <- trial_data
  } else if  (grepl("_neu", datafile) & grepl("hungry", datafile)) {
    org_data_food_hungry <- trial_data
  } else if (grepl("social", datafile) & grepl("sated", datafile)) {
    org_data_social_sated <- trial_data
  } else if  (grepl("social", datafile) & grepl("hungry", datafile)) {
    org_data_social_hungry <- trial_data
  } else if  (grepl("discount", datafile) & grepl("sated", datafile)) {
    org_data_discount_sated <- trial_data
  } else if  (grepl("discount", datafile) & grepl("hungry", datafile)) {
    org_data_discount_hungry <- trial_data
  } 
}
```

#### 2.2 Clothing
```{r}
# data from https://osf.io/d7s6c/ and https://osf.io/f2urs/
# Upleftval/ uprightval/ downleftval/downrightval: preferential ratings of the options at different positions
# ROI: currently gazed location (1: upper left 2: upper right 3: down left 4: down right). 
# NOTE: 
#   choice: left option is chosen (0 or 1)
#   coding: up: cloth's rating; down: brand's rank (20 levels)

# Load data
# data_raw_clothing <- read.csv("../data/moneyrisk.csv") 
load("data/fromYang2022/Brand_Data_Clean.RData")

# Create empty dataframes for each category
data_clothing <- tibble()

# Read in data for all participants in all conditions
# summarize the dwell time for each attribute in each trial (so far the fixation times are stored separately within a trial)
subjlist <- seq_along(brand_present_sub)
for (subject in subjlist) {
  # Get the subject number from the file name
  subjdata <- brand_present_sub[[subject]]
  Ntrial <- sum(subjdata$fixnum == 1)
  # Identify indices where fixnum == 1
  indices <- which(subjdata$fixnum == 1)
  
  # Create a sequence of labels (1, 2, 3, etc.) of the same length as identified indices
  labels <- seq_along(indices)
  
  # Assign these labels to a new column 'fixation_label'
  subjdata$trial <- NA  # Create a new column initialized with NA
  subjdata$trial[indices] <- labels  # Assign labels to the identified rows
  
  for (t in 1:Ntrial) {
    if (t<Ntrial) {
      trial_start <- which(subjdata$trial == t)
      trial_end <- which(subjdata$trial == (t+1))-1
    } else {
      trial_start <- which(subjdata$trial == t)
      trial_end <- nrow(subjdata)
    }
    trial_data <- subjdata[trial_start:trial_end, ]
    Nfix <-  unique(trial_data$fixnum)
    
    #list of variables
    # note: ROI: currently gazed location (1: upper left 2: upper right 3: down left 4: down right). 
    upleft_fix <- sum(trial_data$roi == 1) # cloth's rating
    upright_fix <- sum(trial_data$roi == 2)  # cloth's rating
    downleft_fix <- sum(trial_data$roi == 3) # brand's rank
    downright_fix <- sum(trial_data$roi == 4) # brand's rank 
    upleft_time <- sum(trial_data$fixdur[trial_data$roi == 1])
    upright_time <- sum(trial_data$fixdur[trial_data$roi == 2])
    downleft_time <- sum(trial_data$fixdur[trial_data$roi == 3])
    downright_time <- sum(trial_data$fixdur[trial_data$roi == 4])
    upleft_val <- trial_data$upleftval[1]
    upright_val <- trial_data$uprightval[1]
    downleft_val <- trial_data$downleftval[1]
    downright_val <- trial_data$downrightval[1]
    response <- trial_data$choice[1] #1: left; 0: right
    
    # Create a new row as a data frame
    new_row <- data.frame(
      subject = subject,
      trial = t,
      upleft_val = upleft_val, # cloth's rating
      upright_val = upright_val, # cloth's rating
      downleft_val = downleft_val, # brand's rank
      downright_val = downright_val, # brand's rank
      response = response,
      response_better_up = as.numeric((response == 1 & (upleft_val>upright_val)) | (response == 0 & (upleft_val<=upright_val))), #1: left; 0: right
      RT =  trial_data$rt[1],
      upleft_fix = upleft_fix,
      upright_fix = upright_fix,
      downleft_fix = downleft_fix,
      downright_fix = downright_fix,
      upleft_time = upleft_time,
      upright_time = upright_time,
      downleft_time = downleft_time,
      downright_time = downright_time,
      stringsAsFactors = FALSE  # Ensure character variables are not converted to factors
    )
    data_clothing <- rbind(data_clothing, new_row)
  }
}
```

### 2.3 Social Data from Y&K 2023
JM add new data: social adv and social disadv from Y&K 2023
data from: https://osf.io/d7s6c/files/osfstorage 
```{r}
# Load data
social_adv <- read_csv("data/fromYang2022/socialadv.csv")
social_disadv <-read_csv("data/fromYang2022/socialdisadv.csv")

#function to read in data and put it in correct format
read_yangdata <- function (data){
  data <- data %>%
    group_by(subj, trial) %>%
    summarise(
      # Count fixations for each ROI
      upleft_fix = sum(roi == 1, na.rm = TRUE),
      upright_fix = sum(roi == 2, na.rm = TRUE),
      downleft_fix = sum(roi == 3, na.rm = TRUE),
      downright_fix = sum(roi == 4, na.rm = TRUE),
      
      # Sum fixation durations for each ROI
      upleft_time = sum(ifelse(roi == 1, fixdur, 0), na.rm = TRUE),
      upright_time = sum(ifelse(roi == 2, fixdur, 0), na.rm = TRUE),
      downleft_time = sum(ifelse(roi == 3, fixdur, 0), na.rm = TRUE),
      downright_time = sum(ifelse(roi == 4, fixdur, 0), na.rm = TRUE),
      
      # Keep other variables 
      response = first(choice),
      RT = first(rt),
      upleft_val = first(upleftval),
      upright_val = first(uprightval),
      downleft_val = first(downleftval),
      downright_val = first(downrightval),
      subject = first(subj),
      .groups = 'drop'
    )
  return(data)
}

data_compassion <- read_yangdata(social_adv) 
data_envy <- read_yangdata(social_disadv) 

```




### 3. Add additional info to  dataframes
Include:
- Value differences
- dwell time difference
- dwell time bins (at option level and attribute level)
- zscored dwell difference for each subjects
- proportion of dwell time
#### 3.1 functions
```{r}
calculate_bins <- function(left_time, right_time) {
  fix_sum <- left_time + right_time 
  fix_diff <- left_time - right_time
  if (sum(fix_sum != 0, na.rm = TRUE) > 0) {
    bin_sep <- seq(min(fix_diff, na.rm = TRUE), max(fix_diff, na.rm = TRUE), length.out = 6)
    bins <- cut(fix_diff, breaks = bin_sep, labels = 1:5, include.lowest = TRUE)
    bindata <- bins
  } else {
    bindata <- rep(NaN, length(left_time))
  }
  return(bindata)
}
```

#### 3.2 add variables
```{r}
add_variables <- function(data, data_name) {
  # inclusion criteria
  validT <- data$RT > 250 & is.na(data$RT) == 0
  data <- data[validT,]
  
  
  # dwell difference (left vs. right)
  data$up_dwelldiff <- data$upleft_time - data$upright_time
  data$down_dwelldiff <- data$downleft_time - data$downright_time
  
  # proportion of dwell time
  allfixtime <-
    data$upleft_time + data$upright_time + data$downleft_time + data$downright_time
  data$fixProp1 <- data$upleft_time / allfixtime
  data$fixProp2 <- data$upright_time / allfixtime
  data$fixProp3 <- data$downleft_time / allfixtime
  data$fixProp4 <- data$downright_time / allfixtime
  data$up_fixpropdiff <-
    data$fixProp1 - data$fixProp2 #(left vs. right)
  data$down_fixpropdiff <-
    data$fixProp3 - data$fixProp4 #(left vs. right)
  
  # entropy of dwell time (from Romy's F02_analysis_eyemovement.m, line 327)
  propFix <- data.frame(data$fixProp1,data$fixProp2,data$fixProp3,data$fixProp4)
  propFix <- data.matrix(propFix)
  adder <- 0.00000000000000000000000000000000000001;
  propFix[which(propFix ==0, TRUE)] = adder;
  LogProbFix<- log2(propFix);
  data$DwellVar <- -rowSums(LogProbFix*propFix);
  data$DwellVar[data$DwellVar<0.0000000001] = 0
  
  allfixNum <- data$upleft_fix+data$upright_fix+data$downleft_fix+data$downright_fix
  NumFix <- data.frame(data$upleft_fix,data$upright_fix,data$downleft_fix,data$downright_fix)/allfixNum
  NumFix <- data.matrix(NumFix)
  NumFix[which(NumFix ==0, TRUE)] = adder;
  LogNumFix<- log2(NumFix);
  data$NumFixVar <- -rowSums(LogNumFix*NumFix);
  data$NumFixVar[data$NumFixVar<0.0000000001] = 0
  
  # fixation duration
  data$fixDuration <- allfixtime/allfixNum
  
  # explore all information
  allSee <- as.numeric(data$upleft_fix >0) + as.numeric(data$upright_fix >0) + as.numeric(data$downleft_fix >0) + as.numeric(data$downright_fix >0) 
  data$allSee <- allSee == 4
  
  # more information for model-based analysis
  chooseR <- data$response == 0
  data$RT_right <- data$RT
  data$RT_right[chooseR] <- data$RT_right[chooseR] * -1
  if (grepl("hungry", data_name, ignore.case = TRUE)) {
    data$H <- rep(1, length(data$RT))
  } else {
    data$H <- rep(0, length(data$RT))
  }
  
  # Rescale att. to range from 1 to 10
  data$scl_upleft_val <-
    1 + (data$upleft_val - min(data$upleft_val)) * (10 - 1) / (max(data$upleft_val) - min(data$upleft_val))
  data$scl_upright_val <-
    1 + (data$upright_val - min(data$upright_val)) * (10 - 1) / (max(data$upright_val) - min(data$upright_val))
  data$scl_downleft_val <-
    1 + (data$downleft_val - min(data$downleft_val)) * (10 - 1) / (max(data$downleft_val) - min(data$downleft_val))
  data$scl_downright_val <-
    1 + (data$downright_val - min(data$downright_val)) * (10 - 1) / (max(data$downright_val) - min(data$downright_val))
  
  # reverse the value for time
  if (grepl("discount", data_name, ignore.case = TRUE)) {
    data$scl_upleft_val <- 10 - data$scl_upleft_val # delay
    data$scl_upright_val <- 10 - data$scl_upright_val # delay
  }
  
  # vd of each attribute (left vs. right)
  data$up_vd <- data$scl_upleft_val - data$scl_upright_val
  data$down_vd <- data$scl_downleft_val - data$scl_downright_val
  
  # Initialize z_data
  z_data <- tibble()
  count <- 0
  # Get unique subjects
  subjlist <- unique(data$subject)
  for (s in subjlist) {
    # Create a subset for the current subject
    subjdata <- data[data$subject == s,]
    subjdata$bin_data_fixPropX <- matrix(NA,nrow(subjdata),1)
    subjdata$bin_data_fixPropAdiff <- matrix(NA,nrow(subjdata),1) 
    subjdata$bin_data_fixPropBdiff<- matrix(NA,nrow(subjdata),1)
    # relabel subject numbers from 1 to N
    count <- count + 1
    subjdata$P_subj <- rep(count, length(subjdata$RT))
    
    
    # Label Dwell time difference bins
    subjdata$bin_data_fixPropX <-
      calculate_bins(
        subjdata$fixProp1 + subjdata$fixProp3, 
        0
      )
    
    subjdata$bin_data_fixPropAdiff <-
      calculate_bins(subjdata$fixProp1,
                     subjdata$fixProp2)
    
    subjdata$bin_data_fixPropBdiff <-
      calculate_bins(subjdata$fixProp3,
                     subjdata$fixProp4)
    
    
    
    # Calculate z-scores for each variable
    subjdata$z_A_vd <- scale(subjdata$up_vd)[, 1]
    subjdata$z_B_vd <- scale(subjdata$down_vd)[, 1]
    subjdata$z_option_vd <- scale(subjdata$up_vd+subjdata$down_vd)[, 1]
    subjdata$z_up_dwelldiff <- scale(subjdata$up_dwelldiff)[, 1]
    subjdata$z_down_dwelldiff <- scale(subjdata$down_dwelldiff)[, 1]
    subjdata$z_up_fixpropdiff <- scale(subjdata$up_fixpropdiff)[, 1]
    subjdata$z_down_fixpropdiff <-
      scale(subjdata$down_fixpropdiff)[, 1]
    subjdata$z_option_fixdiff <-
      scale(subjdata$up_dwelldiff + subjdata$down_dwelldiff)[, 1]
    subjdata$z_attribute_fixdiff <-
      scale((subjdata$upleft_time + subjdata$upright_time) - (subjdata$downleft_time +
                                                                subjdata$downright_time)
      )[, 1]
    subjdata$z_fixPropA <-
      scale(subjdata$fixProp1 + subjdata$fixProp2)[, 1]
    
    subjdata$z_fixPropX <-
      scale(subjdata$fixProp1+subjdata$fixProp3)[, 1]
    subjdata$z_fixPropAdiff <-
      scale(subjdata$fixProp1-subjdata$fixProp2)[, 1]
    subjdata$z_fixPropBdiff <-
      scale(subjdata$fixProp3-subjdata$fixProp4)[, 1]
    z_data <- rbind(z_data, subjdata)
    
    
  }
  return(z_data)
}

# List of dataset names
dataset_names <- c("org_data_food_sated", "org_data_food_hungry", "org_data_social_sated", "org_data_social_hungry", "org_data_discount_sated", "org_data_discount_hungry", "data_clothing", "data_compassion", "data_envy")

# Loop through the datasets and apply the add_variables function
for (name in dataset_names) {
  assign(name, add_variables(get(name), name))
}

# Save the modified datasets
save(org_data_food_sated, org_data_food_hungry, org_data_social_sated, org_data_social_hungry, org_data_discount_sated, org_data_discount_hungry, data_clothing, data_compassion, data_envy, file = "data/datasets.RData")
```